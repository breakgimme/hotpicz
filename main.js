/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@atproto/api/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@atproto/api/dist/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from3, except, desc) => {\n  if (from3 && typeof from3 === \"object\" || typeof from3 === \"function\") {\n    for (let key of __getOwnPropNames(from3))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// ../../node_modules/iso-datestring-validator/dist/index.js\nvar require_dist = __commonJS({\n  \"../../node_modules/iso-datestring-validator/dist/index.js\"(exports) {\n    (() => {\n      \"use strict\";\n      var e = { d: (t2, r2) => {\n        for (var n2 in r2)\n          e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });\n      }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e2, \"__esModule\", { value: true });\n      } }, t = {};\n      function r(e2, t2) {\n        return void 0 === t2 && (t2 = \"-\"), new RegExp(\"^(?!0{4}\" + t2 + \"0{2}\" + t2 + \"0{2})((?=[0-9]{4}\" + t2 + \"(((0[^2])|1[0-2])|02(?=\" + t2 + \"(([0-1][0-9])|2[0-8])))\" + t2 + \"[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))\" + t2 + \"02\" + t2 + \"29))([0-9]{4})\" + t2 + \"(?!((0[469])|11)\" + t2 + \"31)((0[1,3-9]|1[0-2])|(02(?!\" + t2 + \"3)))\" + t2 + \"(0[1-9]|[1-2][0-9]|3[0-1])$\").test(e2);\n      }\n      function n(e2) {\n        var t2 = /\\D/.exec(e2);\n        return t2 ? t2[0] : \"\";\n      }\n      function i(e2, t2, r2) {\n        void 0 === t2 && (t2 = \":\"), void 0 === r2 && (r2 = false);\n        var i2 = new RegExp(\"^([0-1]|2(?=([0-3])|4\" + t2 + \"00))[0-9]\" + t2 + \"[0-5][0-9](\" + t2 + \"([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$\");\n        if (!r2 || !/[Z+\\-]/.test(e2))\n          return i2.test(e2);\n        if (/Z$/.test(e2))\n          return i2.test(e2.replace(\"Z\", \"\"));\n        var o2 = e2.includes(\"+\"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];\n        return i2.test(u2) && function(e3, t3, r3) {\n          return void 0 === r3 && (r3 = \":\"), new RegExp(t3 ? \"^(0(?!(2\" + r3 + \"4)|0\" + r3 + \"3)|1(?=([0-1]|2(?=\" + r3 + \"[04])|[34](?=\" + r3 + \"0))))([03469](?=\" + r3 + \"[03])|[17](?=\" + r3 + \"0)|2(?=\" + r3 + \"[04])|5(?=\" + r3 + \"[034])|8(?=\" + r3 + \"[04]))\" + r3 + \"([03](?=0)|4(?=5))[05]$\" : \"^(0(?=[^0])|1(?=[0-2]))([39](?=\" + r3 + \"[03])|[0-24-8](?=\" + r3 + \"00))\" + r3 + \"[03]0$\").test(e3);\n        }(d2, o2, n(d2));\n      }\n      function o(e2) {\n        var t2 = e2.split(\"T\"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));\n        if (!a2)\n          return false;\n        var d2, s = (d2 = a2.match(/([^Z+\\-\\d])(?=\\d+\\1)/), Array.isArray(d2) ? d2[0] : \"\");\n        return u2 && i(a2, s, true);\n      }\n      function a(e2, t2) {\n        return void 0 === t2 && (t2 = \"-\"), new RegExp(\"^[0-9]{4}\" + t2 + \"(0(?=[^0])|1(?=[0-2]))[0-9]$\").test(e2);\n      }\n      e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });\n      var u = exports;\n      for (var d in t)\n        u[d] = t[d];\n      t.__esModule && Object.defineProperty(u, \"__esModule\", { value: true });\n    })();\n  }\n});\n\n// src/index.ts\nvar src_exports4 = {};\n__export(src_exports4, {\n  ActorNS: () => ActorNS,\n  AdminNS: () => AdminNS,\n  AppBskyActorDefs: () => defs_exports5,\n  AppBskyActorGetProfile: () => getProfile_exports,\n  AppBskyActorGetProfiles: () => getProfiles_exports,\n  AppBskyActorGetSuggestions: () => getSuggestions_exports,\n  AppBskyActorProfile: () => profile_exports,\n  AppBskyActorSearchActors: () => searchActors_exports,\n  AppBskyActorSearchActorsTypeahead: () => searchActorsTypeahead_exports,\n  AppBskyEmbedExternal: () => external_exports,\n  AppBskyEmbedImages: () => images_exports,\n  AppBskyEmbedRecord: () => record_exports,\n  AppBskyEmbedRecordWithMedia: () => recordWithMedia_exports,\n  AppBskyFeedDefs: () => defs_exports6,\n  AppBskyFeedGetAuthorFeed: () => getAuthorFeed_exports,\n  AppBskyFeedGetLikes: () => getLikes_exports,\n  AppBskyFeedGetPostThread: () => getPostThread_exports,\n  AppBskyFeedGetPosts: () => getPosts_exports,\n  AppBskyFeedGetRepostedBy: () => getRepostedBy_exports,\n  AppBskyFeedGetTimeline: () => getTimeline_exports,\n  AppBskyFeedLike: () => like_exports,\n  AppBskyFeedPost: () => post_exports,\n  AppBskyFeedRepost: () => repost_exports,\n  AppBskyGraphBlock: () => block_exports,\n  AppBskyGraphFollow: () => follow_exports,\n  AppBskyGraphGetBlocks: () => getBlocks_exports2,\n  AppBskyGraphGetFollowers: () => getFollowers_exports,\n  AppBskyGraphGetFollows: () => getFollows_exports,\n  AppBskyGraphGetMutes: () => getMutes_exports,\n  AppBskyGraphMuteActor: () => muteActor_exports,\n  AppBskyGraphUnmuteActor: () => unmuteActor_exports,\n  AppBskyNotificationGetUnreadCount: () => getUnreadCount_exports,\n  AppBskyNotificationListNotifications: () => listNotifications_exports,\n  AppBskyNotificationUpdateSeen: () => updateSeen_exports,\n  AppBskyRichtextFacet: () => facet_exports,\n  AppBskyUnspeccedGetPopular: () => getPopular_exports,\n  AppNS: () => AppNS,\n  AtUri: () => AtUri,\n  AtpAgent: () => AtpAgent,\n  AtpBaseClient: () => AtpBaseClient,\n  AtpServiceClient: () => AtpServiceClient,\n  AtprotoNS: () => AtprotoNS,\n  BlobRef: () => BlobRef,\n  BlockRecord: () => BlockRecord,\n  BskyAgent: () => BskyAgent,\n  BskyNS: () => BskyNS,\n  COM_ATPROTO_ADMIN: () => COM_ATPROTO_ADMIN,\n  COM_ATPROTO_MODERATION: () => COM_ATPROTO_MODERATION,\n  ComAtprotoAdminDefs: () => defs_exports,\n  ComAtprotoAdminDisableInviteCodes: () => disableInviteCodes_exports,\n  ComAtprotoAdminGetInviteCodes: () => getInviteCodes_exports,\n  ComAtprotoAdminGetModerationAction: () => getModerationAction_exports,\n  ComAtprotoAdminGetModerationActions: () => getModerationActions_exports,\n  ComAtprotoAdminGetModerationReport: () => getModerationReport_exports,\n  ComAtprotoAdminGetModerationReports: () => getModerationReports_exports,\n  ComAtprotoAdminGetRecord: () => getRecord_exports,\n  ComAtprotoAdminGetRepo: () => getRepo_exports,\n  ComAtprotoAdminResolveModerationReports: () => resolveModerationReports_exports,\n  ComAtprotoAdminReverseModerationAction: () => reverseModerationAction_exports,\n  ComAtprotoAdminSearchRepos: () => searchRepos_exports,\n  ComAtprotoAdminTakeModerationAction: () => takeModerationAction_exports,\n  ComAtprotoAdminUpdateAccountEmail: () => updateAccountEmail_exports,\n  ComAtprotoAdminUpdateAccountHandle: () => updateAccountHandle_exports,\n  ComAtprotoIdentityResolveHandle: () => resolveHandle_exports,\n  ComAtprotoIdentityUpdateHandle: () => updateHandle_exports,\n  ComAtprotoLabelDefs: () => defs_exports2,\n  ComAtprotoLabelQueryLabels: () => queryLabels_exports,\n  ComAtprotoLabelSubscribeLabels: () => subscribeLabels_exports,\n  ComAtprotoModerationCreateReport: () => createReport_exports,\n  ComAtprotoModerationDefs: () => defs_exports3,\n  ComAtprotoRepoApplyWrites: () => applyWrites_exports,\n  ComAtprotoRepoCreateRecord: () => createRecord_exports,\n  ComAtprotoRepoDeleteRecord: () => deleteRecord_exports,\n  ComAtprotoRepoDescribeRepo: () => describeRepo_exports,\n  ComAtprotoRepoGetRecord: () => getRecord_exports2,\n  ComAtprotoRepoListRecords: () => listRecords_exports,\n  ComAtprotoRepoPutRecord: () => putRecord_exports,\n  ComAtprotoRepoStrongRef: () => strongRef_exports,\n  ComAtprotoRepoUploadBlob: () => uploadBlob_exports,\n  ComAtprotoServerCreateAccount: () => createAccount_exports,\n  ComAtprotoServerCreateAppPassword: () => createAppPassword_exports,\n  ComAtprotoServerCreateInviteCode: () => createInviteCode_exports,\n  ComAtprotoServerCreateInviteCodes: () => createInviteCodes_exports,\n  ComAtprotoServerCreateSession: () => createSession_exports,\n  ComAtprotoServerDefs: () => defs_exports4,\n  ComAtprotoServerDeleteAccount: () => deleteAccount_exports,\n  ComAtprotoServerDeleteSession: () => deleteSession_exports,\n  ComAtprotoServerDescribeServer: () => describeServer_exports,\n  ComAtprotoServerGetAccountInviteCodes: () => getAccountInviteCodes_exports,\n  ComAtprotoServerGetSession: () => getSession_exports,\n  ComAtprotoServerListAppPasswords: () => listAppPasswords_exports,\n  ComAtprotoServerRefreshSession: () => refreshSession_exports,\n  ComAtprotoServerRequestAccountDelete: () => requestAccountDelete_exports,\n  ComAtprotoServerRequestPasswordReset: () => requestPasswordReset_exports,\n  ComAtprotoServerResetPassword: () => resetPassword_exports,\n  ComAtprotoServerRevokeAppPassword: () => revokeAppPassword_exports,\n  ComAtprotoSyncGetBlob: () => getBlob_exports,\n  ComAtprotoSyncGetBlocks: () => getBlocks_exports,\n  ComAtprotoSyncGetCheckout: () => getCheckout_exports,\n  ComAtprotoSyncGetCommitPath: () => getCommitPath_exports,\n  ComAtprotoSyncGetHead: () => getHead_exports,\n  ComAtprotoSyncGetRecord: () => getRecord_exports3,\n  ComAtprotoSyncGetRepo: () => getRepo_exports2,\n  ComAtprotoSyncListBlobs: () => listBlobs_exports,\n  ComAtprotoSyncListRepos: () => listRepos_exports,\n  ComAtprotoSyncNotifyOfUpdate: () => notifyOfUpdate_exports,\n  ComAtprotoSyncRequestCrawl: () => requestCrawl_exports,\n  ComAtprotoSyncSubscribeRepos: () => subscribeRepos_exports,\n  ComNS: () => ComNS,\n  EmbedNS: () => EmbedNS,\n  FeedNS: () => FeedNS,\n  FollowRecord: () => FollowRecord,\n  GraphNS: () => GraphNS,\n  IdentityNS: () => IdentityNS,\n  LabelNS: () => LabelNS,\n  LikeRecord: () => LikeRecord,\n  ModerationNS: () => ModerationNS,\n  NotificationNS: () => NotificationNS,\n  PostRecord: () => PostRecord,\n  ProfileRecord: () => ProfileRecord,\n  RepoNS: () => RepoNS,\n  RepostRecord: () => RepostRecord,\n  RichText: () => RichText,\n  RichTextSegment: () => RichTextSegment,\n  RichtextNS: () => RichtextNS,\n  ServerNS: () => ServerNS,\n  SyncNS: () => SyncNS,\n  UnicodeString: () => UnicodeString,\n  UnspeccedNS: () => UnspeccedNS,\n  default: () => AtpAgent,\n  jsonStringToLex: () => jsonStringToLex,\n  jsonToLex: () => jsonToLex,\n  lexToJson: () => lexToJson,\n  sanitizeRichText: () => sanitizeRichText,\n  stringifyLex: () => stringifyLex\n});\nmodule.exports = __toCommonJS(src_exports4);\n\n// ../common-web/src/check.ts\nvar check_exports = {};\n__export(check_exports, {\n  assure: () => assure,\n  is: () => is,\n  isObject: () => isObject\n});\nvar is = (obj, def2) => {\n  return def2.safeParse(obj).success;\n};\nvar assure = (def2, obj) => {\n  return def2.parse(obj);\n};\nvar isObject = (obj) => {\n  return typeof obj === \"object\" && obj !== null;\n};\n\n// ../../node_modules/multiformats/esm/vendor/varint.js\nvar encode_1 = encode;\nvar MSB = 128;\nvar REST = 127;\nvar MSBALL = ~REST;\nvar INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128;\nvar REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError(\"Could not decode varint\");\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function(value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nvar varint_default = _brrp_varint;\n\n// ../../node_modules/multiformats/esm/src/varint.js\nvar decode2 = (data, offset = 0) => {\n  const code2 = varint_default.decode(data, offset);\n  return [\n    code2,\n    varint_default.decode.bytes\n  ];\n};\nvar encodeTo = (int, target, offset = 0) => {\n  varint_default.encode(int, target, offset);\n  return target;\n};\nvar encodingLength = (int) => {\n  return varint_default.encodingLength(int);\n};\n\n// ../../node_modules/multiformats/esm/src/bytes.js\nvar empty = new Uint8Array(0);\nvar equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nvar coerce = (o) => {\n  if (o instanceof Uint8Array && o.constructor.name === \"Uint8Array\")\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error(\"Unknown type, must be binary type\");\n};\nvar fromString = (str) => new TextEncoder().encode(str);\nvar toString = (b) => new TextDecoder().decode(b);\n\n// ../../node_modules/multiformats/esm/src/hashes/digest.js\nvar create = (code2, digest2) => {\n  const size = digest2.byteLength;\n  const sizeOffset = encodingLength(code2);\n  const digestOffset = sizeOffset + encodingLength(size);\n  const bytes2 = new Uint8Array(digestOffset + size);\n  encodeTo(code2, bytes2, 0);\n  encodeTo(size, bytes2, sizeOffset);\n  bytes2.set(digest2, digestOffset);\n  return new Digest(code2, size, digest2, bytes2);\n};\nvar decode3 = (multihash) => {\n  const bytes2 = coerce(multihash);\n  const [code2, sizeOffset] = decode2(bytes2);\n  const [size, digestOffset] = decode2(bytes2.subarray(sizeOffset));\n  const digest2 = bytes2.subarray(sizeOffset + digestOffset);\n  if (digest2.byteLength !== size) {\n    throw new Error(\"Incorrect length\");\n  }\n  return new Digest(code2, size, digest2, bytes2);\n};\nvar equals2 = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);\n  }\n};\nvar Digest = class {\n  constructor(code2, size, digest2, bytes2) {\n    this.code = code2;\n    this.size = size;\n    this.digest = digest2;\n    this.bytes = bytes2;\n  }\n};\n\n// ../../node_modules/multiformats/esm/src/bases/base58.js\nvar base58_exports = {};\n__export(base58_exports, {\n  base58btc: () => base58btc,\n  base58flickr: () => base58flickr\n});\n\n// ../../node_modules/multiformats/esm/vendor/base-x.js\nfunction base(ALPHABET, name2) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError(\"Alphabet too long\");\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + \" is ambiguous\");\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode5(source) {\n    if (source instanceof Uint8Array)\n      ;\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n      return \"\";\n    }\n    var zeroes = 0;\n    var length2 = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i2 = 0;\n      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error(\"Non-zero carry\");\n      }\n      length2 = i2;\n      pbegin++;\n    }\n    var it2 = size - length2;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== \"string\") {\n      throw new TypeError(\"Expected String\");\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === \" \") {\n      return;\n    }\n    var zeroes = 0;\n    var length2 = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i2 = 0;\n      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error(\"Non-zero carry\");\n      }\n      length2 = i2;\n      psz++;\n    }\n    if (source[psz] === \" \") {\n      return;\n    }\n    var it4 = size - length2;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j2 = zeroes;\n    while (it4 !== size) {\n      vch[j2++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode6(string3) {\n    var buffer = decodeUnsafe(string3);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${name2} character`);\n  }\n  return {\n    encode: encode5,\n    decodeUnsafe,\n    decode: decode6\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nvar base_x_default = _brrp__multiformats_scope_baseX;\n\n// ../../node_modules/multiformats/esm/src/bases/base.js\nvar Encoder = class {\n  constructor(name2, prefix, baseEncode) {\n    this.name = name2;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes2) {\n    if (bytes2 instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes2)}`;\n    } else {\n      throw Error(\"Unknown type, must be binary type\");\n    }\n  }\n};\nvar Decoder = class {\n  constructor(name2, prefix, baseDecode) {\n    this.name = name2;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === void 0) {\n      throw new Error(\"Invalid prefix character\");\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === \"string\") {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error(\"Can only multibase decode strings\");\n    }\n  }\n  or(decoder2) {\n    return or(this, decoder2);\n  }\n};\nvar ComposedDecoder = class {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder2) {\n    return or(this, decoder2);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder2 = this.decoders[prefix];\n    if (decoder2) {\n      return decoder2.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n};\nvar or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nvar Codec = class {\n  constructor(name2, prefix, baseEncode, baseDecode) {\n    this.name = name2;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name2, prefix, baseEncode);\n    this.decoder = new Decoder(name2, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n};\nvar from = ({ name: name2, prefix, encode: encode5, decode: decode6 }) => new Codec(name2, prefix, encode5, decode6);\nvar baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {\n  const { encode: encode5, decode: decode6 } = base_x_default(alphabet2, name2);\n  return from({\n    prefix,\n    name: name2,\n    encode: encode5,\n    decode: (text) => coerce(decode6(text))\n  });\n};\nvar decode4 = (string3, alphabet2, bitsPerChar, name2) => {\n  const codes = {};\n  for (let i = 0; i < alphabet2.length; ++i) {\n    codes[alphabet2[i]] = i;\n  }\n  let end = string3.length;\n  while (string3[end - 1] === \"=\") {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string3[i]];\n    if (value === void 0) {\n      throw new SyntaxError(`Non-${name2} character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError(\"Unexpected end of data\");\n  }\n  return out;\n};\nvar encode2 = (data, alphabet2, bitsPerChar) => {\n  const pad = alphabet2[alphabet2.length - 1] === \"=\";\n  const mask = (1 << bitsPerChar) - 1;\n  let out = \"\";\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet2[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet2[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += \"=\";\n    }\n  }\n  return out;\n};\nvar rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {\n  return from({\n    prefix,\n    name: name2,\n    encode(input) {\n      return encode2(input, alphabet2, bitsPerChar);\n    },\n    decode(input) {\n      return decode4(input, alphabet2, bitsPerChar, name2);\n    }\n  });\n};\n\n// ../../node_modules/multiformats/esm/src/bases/base58.js\nvar base58btc = baseX({\n  name: \"base58btc\",\n  prefix: \"z\",\n  alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n});\nvar base58flickr = baseX({\n  name: \"base58flickr\",\n  prefix: \"Z\",\n  alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base32.js\nvar base32_exports = {};\n__export(base32_exports, {\n  base32: () => base32,\n  base32hex: () => base32hex,\n  base32hexpad: () => base32hexpad,\n  base32hexpadupper: () => base32hexpadupper,\n  base32hexupper: () => base32hexupper,\n  base32pad: () => base32pad,\n  base32padupper: () => base32padupper,\n  base32upper: () => base32upper,\n  base32z: () => base32z\n});\nvar base32 = rfc4648({\n  prefix: \"b\",\n  name: \"base32\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n  bitsPerChar: 5\n});\nvar base32upper = rfc4648({\n  prefix: \"B\",\n  name: \"base32upper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  bitsPerChar: 5\n});\nvar base32pad = rfc4648({\n  prefix: \"c\",\n  name: \"base32pad\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n  bitsPerChar: 5\n});\nvar base32padupper = rfc4648({\n  prefix: \"C\",\n  name: \"base32padupper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n  bitsPerChar: 5\n});\nvar base32hex = rfc4648({\n  prefix: \"v\",\n  name: \"base32hex\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n  bitsPerChar: 5\n});\nvar base32hexupper = rfc4648({\n  prefix: \"V\",\n  name: \"base32hexupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  bitsPerChar: 5\n});\nvar base32hexpad = rfc4648({\n  prefix: \"t\",\n  name: \"base32hexpad\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n  bitsPerChar: 5\n});\nvar base32hexpadupper = rfc4648({\n  prefix: \"T\",\n  name: \"base32hexpadupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n  bitsPerChar: 5\n});\nvar base32z = rfc4648({\n  prefix: \"h\",\n  name: \"base32z\",\n  alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n  bitsPerChar: 5\n});\n\n// ../../node_modules/multiformats/esm/src/cid.js\nvar CID = class {\n  constructor(version2, code2, multihash, bytes2) {\n    this.code = code2;\n    this.version = version2;\n    this.multihash = multihash;\n    this.bytes = bytes2;\n    this.byteOffset = bytes2.byteOffset;\n    this.byteLength = bytes2.byteLength;\n    this.asCID = this;\n    this._baseCache = /* @__PURE__ */ new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n      case 0: {\n        return this;\n      }\n      default: {\n        const { code: code2, multihash } = this;\n        if (code2 !== DAG_PB_CODE) {\n          throw new Error(\"Cannot convert a non dag-pb CID to CIDv0\");\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error(\"Cannot convert non sha2-256 multihash CID to CIDv0\");\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n      case 0: {\n        const { code: code2, digest: digest2 } = this.multihash;\n        const multihash = create(code2, digest2);\n        return CID.createV1(this.code, multihash);\n      }\n      case 1: {\n        return this;\n      }\n      default: {\n        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);\n  }\n  toString(base3) {\n    const { bytes: bytes2, version: version2, _baseCache } = this;\n    switch (version2) {\n      case 0:\n        return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);\n      default:\n        return toStringV1(bytes2, _baseCache, base3 || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"CID\";\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return \"CID(\" + this.toString() + \")\";\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error(\"Deprecated, use .toString()\");\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error(\"Deprecated .buffer property, use .bytes to get Uint8Array instead\");\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;\n      return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const { version: version2, multihash, code: code2 } = value;\n      const digest2 = decode3(multihash);\n      return CID.create(version2, code2, digest2);\n    } else {\n      return null;\n    }\n  }\n  static create(version2, code2, digest2) {\n    if (typeof code2 !== \"number\") {\n      throw new Error(\"String codecs are no longer supported\");\n    }\n    switch (version2) {\n      case 0: {\n        if (code2 !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n        } else {\n          return new CID(version2, code2, digest2, digest2.bytes);\n        }\n      }\n      case 1: {\n        const bytes2 = encodeCID(version2, code2, digest2.bytes);\n        return new CID(version2, code2, digest2, bytes2);\n      }\n      default: {\n        throw new Error(\"Invalid version\");\n      }\n    }\n  }\n  static createV0(digest2) {\n    return CID.create(0, DAG_PB_CODE, digest2);\n  }\n  static createV1(code2, digest2) {\n    return CID.create(1, code2, digest2);\n  }\n  static decode(bytes2) {\n    const [cid2, remainder] = CID.decodeFirst(bytes2);\n    if (remainder.length) {\n      throw new Error(\"Incorrect length\");\n    }\n    return cid2;\n  }\n  static decodeFirst(bytes2) {\n    const specs = CID.inspectBytes(bytes2);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error(\"Incorrect length\");\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid2 = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);\n    return [\n      cid2,\n      bytes2.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length2] = decode2(initialBytes.subarray(offset));\n      offset += length2;\n      return i;\n    };\n    let version2 = next();\n    let codec = DAG_PB_CODE;\n    if (version2 === 18) {\n      version2 = 0;\n      offset = 0;\n    } else if (version2 === 1) {\n      codec = next();\n    }\n    if (version2 !== 0 && version2 !== 1) {\n      throw new RangeError(`Invalid CID version ${version2}`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version: version2,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base3) {\n    const [prefix, bytes2] = parseCIDtoBytes(source, base3);\n    const cid2 = CID.decode(bytes2);\n    cid2._baseCache.set(prefix, source);\n    return cid2;\n  }\n};\nvar parseCIDtoBytes = (source, base3) => {\n  switch (source[0]) {\n    case \"Q\": {\n      const decoder2 = base3 || base58btc;\n      return [\n        base58btc.prefix,\n        decoder2.decode(`${base58btc.prefix}${source}`)\n      ];\n    }\n    case base58btc.prefix: {\n      const decoder2 = base3 || base58btc;\n      return [\n        base58btc.prefix,\n        decoder2.decode(source)\n      ];\n    }\n    case base32.prefix: {\n      const decoder2 = base3 || base32;\n      return [\n        base32.prefix,\n        decoder2.decode(source)\n      ];\n    }\n    default: {\n      if (base3 == null) {\n        throw Error(\"To parse non base32 or base58btc encoded CID multibase decoder must be provided\");\n      }\n      return [\n        source[0],\n        base3.decode(source)\n      ];\n    }\n  }\n};\nvar toStringV0 = (bytes2, cache, base3) => {\n  const { prefix } = base3;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);\n  }\n  const cid2 = cache.get(prefix);\n  if (cid2 == null) {\n    const cid3 = base3.encode(bytes2).slice(1);\n    cache.set(prefix, cid3);\n    return cid3;\n  } else {\n    return cid2;\n  }\n};\nvar toStringV1 = (bytes2, cache, base3) => {\n  const { prefix } = base3;\n  const cid2 = cache.get(prefix);\n  if (cid2 == null) {\n    const cid3 = base3.encode(bytes2);\n    cache.set(prefix, cid3);\n    return cid3;\n  } else {\n    return cid2;\n  }\n};\nvar DAG_PB_CODE = 112;\nvar SHA_256_CODE = 18;\nvar encodeCID = (version2, code2, multihash) => {\n  const codeOffset = encodingLength(version2);\n  const hashOffset = codeOffset + encodingLength(code2);\n  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);\n  encodeTo(version2, bytes2, 0);\n  encodeTo(code2, bytes2, codeOffset);\n  bytes2.set(multihash, hashOffset);\n  return bytes2;\n};\nvar cidSymbol = Symbol.for(\"@ipld/js-cid/CID\");\nvar readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nvar hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nvar version = \"0.0.0-dev\";\nvar deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nvar IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;\n\n// ../../node_modules/multiformats/esm/src/bases/identity.js\nvar identity_exports = {};\n__export(identity_exports, {\n  identity: () => identity\n});\nvar identity = from({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base2.js\nvar base2_exports = {};\n__export(base2_exports, {\n  base2: () => base2\n});\nvar base2 = rfc4648({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base8.js\nvar base8_exports = {};\n__export(base8_exports, {\n  base8: () => base8\n});\nvar base8 = rfc4648({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base10.js\nvar base10_exports = {};\n__export(base10_exports, {\n  base10: () => base10\n});\nvar base10 = baseX({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base16.js\nvar base16_exports = {};\n__export(base16_exports, {\n  base16: () => base16,\n  base16upper: () => base16upper\n});\nvar base16 = rfc4648({\n  prefix: \"f\",\n  name: \"base16\",\n  alphabet: \"0123456789abcdef\",\n  bitsPerChar: 4\n});\nvar base16upper = rfc4648({\n  prefix: \"F\",\n  name: \"base16upper\",\n  alphabet: \"0123456789ABCDEF\",\n  bitsPerChar: 4\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base36.js\nvar base36_exports = {};\n__export(base36_exports, {\n  base36: () => base36,\n  base36upper: () => base36upper\n});\nvar base36 = baseX({\n  prefix: \"k\",\n  name: \"base36\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n});\nvar base36upper = baseX({\n  prefix: \"K\",\n  name: \"base36upper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base64.js\nvar base64_exports = {};\n__export(base64_exports, {\n  base64: () => base64,\n  base64pad: () => base64pad,\n  base64url: () => base64url,\n  base64urlpad: () => base64urlpad\n});\nvar base64 = rfc4648({\n  prefix: \"m\",\n  name: \"base64\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  bitsPerChar: 6\n});\nvar base64pad = rfc4648({\n  prefix: \"M\",\n  name: \"base64pad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  bitsPerChar: 6\n});\nvar base64url = rfc4648({\n  prefix: \"u\",\n  name: \"base64url\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n  bitsPerChar: 6\n});\nvar base64urlpad = rfc4648({\n  prefix: \"U\",\n  name: \"base64urlpad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n  bitsPerChar: 6\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base256emoji.js\nvar base256emoji_exports = {};\n__export(base256emoji_exports, {\n  base256emoji: () => base256emoji\n});\nvar alphabet = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\");\nvar alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nvar alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode3(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, \"\");\n}\nfunction decode5(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === void 0) {\n      throw new Error(`Non-base256emoji character: ${char}`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nvar base256emoji = from({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: encode3,\n  decode: decode5\n});\n\n// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js\nvar sha2_browser_exports = {};\n__export(sha2_browser_exports, {\n  sha256: () => sha256,\n  sha512: () => sha512\n});\n\n// ../../node_modules/multiformats/esm/src/hashes/hasher.js\nvar from2 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);\nvar Hasher = class {\n  constructor(name2, code2, encode5) {\n    this.name = name2;\n    this.code = code2;\n    this.encode = encode5;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));\n    } else {\n      throw Error(\"Unknown type, must be binary type\");\n    }\n  }\n};\n\n// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js\nvar sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));\nvar sha256 = from2({\n  name: \"sha2-256\",\n  code: 18,\n  encode: sha(\"SHA-256\")\n});\nvar sha512 = from2({\n  name: \"sha2-512\",\n  code: 19,\n  encode: sha(\"SHA-512\")\n});\n\n// ../../node_modules/multiformats/esm/src/hashes/identity.js\nvar identity_exports2 = {};\n__export(identity_exports2, {\n  identity: () => identity2\n});\nvar code = 0;\nvar name = \"identity\";\nvar encode4 = coerce;\nvar digest = (input) => create(code, encode4(input));\nvar identity2 = {\n  code,\n  name,\n  encode: encode4,\n  digest\n};\n\n// ../../node_modules/multiformats/esm/src/codecs/json.js\nvar textEncoder = new TextEncoder();\nvar textDecoder = new TextDecoder();\n\n// ../../node_modules/multiformats/esm/src/basics.js\nvar bases = {\n  ...identity_exports,\n  ...base2_exports,\n  ...base8_exports,\n  ...base10_exports,\n  ...base16_exports,\n  ...base32_exports,\n  ...base36_exports,\n  ...base58_exports,\n  ...base64_exports,\n  ...base256emoji_exports\n};\nvar hashes = {\n  ...sha2_browser_exports,\n  ...identity_exports2\n};\n\n// ../../node_modules/uint8arrays/esm/src/util/bases.js\nfunction createCodec(name2, prefix, encode5, decode6) {\n  return {\n    name: name2,\n    prefix,\n    encoder: {\n      name: name2,\n      prefix,\n      encode: encode5\n    },\n    decoder: { decode: decode6 }\n  };\n}\nvar string = createCodec(\"utf8\", \"u\", (buf) => {\n  const decoder2 = new TextDecoder(\"utf8\");\n  return \"u\" + decoder2.decode(buf);\n}, (str) => {\n  const encoder2 = new TextEncoder();\n  return encoder2.encode(str.substring(1));\n});\nvar ascii = createCodec(\"ascii\", \"a\", (buf) => {\n  let string3 = \"a\";\n  for (let i = 0; i < buf.length; i++) {\n    string3 += String.fromCharCode(buf[i]);\n  }\n  return string3;\n}, (str) => {\n  str = str.substring(1);\n  const buf = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nvar BASES = {\n  utf8: string,\n  \"utf-8\": string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n  ...bases\n};\nvar bases_default = BASES;\n\n// ../../node_modules/uint8arrays/esm/src/from-string.js\nfunction fromString2(string3, encoding = \"utf8\") {\n  const base3 = bases_default[encoding];\n  if (!base3) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`);\n  }\n  return base3.decoder.decode(`${base3.prefix}${string3}`);\n}\n\n// ../../node_modules/uint8arrays/esm/src/to-string.js\nfunction toString2(array2, encoding = \"utf8\") {\n  const base3 = bases_default[encoding];\n  if (!base3) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`);\n  }\n  return base3.encoder.encode(array2).substring(1);\n}\n\n// ../common-web/src/ipld.ts\nvar jsonToIpld = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => jsonToIpld(item));\n  }\n  if (val && typeof val === \"object\") {\n    if (typeof val[\"$link\"] === \"string\" && Object.keys(val).length === 1) {\n      return CID.parse(val[\"$link\"]);\n    }\n    if (typeof val[\"$bytes\"] === \"string\" && Object.keys(val).length === 1) {\n      return fromString2(val[\"$bytes\"], \"base64\");\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = jsonToIpld(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\nvar ipldToJson = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => ipldToJson(item));\n  }\n  if (val && typeof val === \"object\") {\n    if (val instanceof Uint8Array) {\n      return {\n        $bytes: toString2(val, \"base64\")\n      };\n    }\n    if (CID.asCID(val)) {\n      return {\n        $link: val.toString()\n      };\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = ipldToJson(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\n\n// ../../node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n  util2.assertEqual = (val) => val;\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object2) => {\n    const keys = [];\n    for (const key in object2) {\n      if (Object.prototype.hasOwnProperty.call(object2, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n  function joinValues(array2, separator = \" | \") {\n    return array2.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\nvar ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class extends Error {\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  get errors() {\n    return this.issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n        fieldErrors[sub.path[0]].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\nvar errorMap = (issue, _ctx) => {\n  let message;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"startsWith\" in issue.validation) {\n          message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be greater than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.minimum)}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be smaller than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.maximum)}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar makeIssue = (params2) => {\n  const { data, path, errorMaps, issueData } = params2;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: issueData.message || errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      getErrorMap(),\n      errorMap\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\")\n      this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\")\n      this.value = \"aborted\";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      if (s.status === \"dirty\")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      syncPairs.push({\n        key: await pair.key,\n        value: await pair.value\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\")\n        return INVALID;\n      if (value.status === \"aborted\")\n        return INVALID;\n      if (key.status === \"dirty\")\n        status.dirty();\n      if (value.status === \"dirty\")\n        status.dirty();\n      if (typeof value.value !== \"undefined\" || pair.alwaysSet) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n};\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = (value) => ({ status: \"dirty\", value });\nvar OK = (value) => ({ status: \"valid\", value });\nvar isAborted = (x) => x.status === \"aborted\";\nvar isDirty = (x) => x.status === \"dirty\";\nvar isValid = (x) => x.status === \"valid\";\nvar isAsync = (x) => typeof Promise !== void 0 && x instanceof Promise;\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path, key) {\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    return this._path.concat(this._key);\n  }\n};\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    const error = new ZodError(ctx.common.issues);\n    return { success: false, error };\n  }\n};\nfunction processCreateParams(params2) {\n  if (!params2)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    if (typeof ctx.data === \"undefined\") {\n      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n    }\n    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\nvar ZodType = class {\n  constructor(def2) {\n    this.spa = this.safeParseAsync;\n    this.superRefine = this._refinement;\n    this._def = def2;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.default = this.default.bind(this);\n    this.describe = this.describe.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n  }\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params2) {\n    const result = this.safeParse(data, params2);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params2) {\n    var _a;\n    const ctx = {\n      common: {\n        issues: [],\n        async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,\n        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap\n      },\n      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  async parseAsync(data, params2) {\n    const result = await this.safeParseAsync(data, params2);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params2) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,\n        async: true\n      },\n      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  optional() {\n    return ZodOptional.create(this);\n  }\n  nullable() {\n    return ZodNullable.create(this);\n  }\n  nullish() {\n    return this.optional().nullable();\n  }\n  array() {\n    return ZodArray.create(this);\n  }\n  promise() {\n    return ZodPromise.create(this);\n  }\n  or(option) {\n    return ZodUnion.create([this, option]);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def2) {\n    const defaultValueFunc = typeof def2 === \"function\" ? def2 : () => def2;\n    return new ZodDefault({\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(void 0)\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nvar emailRegex = /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\nvar ZodString = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n    this.trim = () => new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(\n        ctx2,\n        {\n          code: ZodIssueCode.invalid_type,\n          expected: ZodParsedType.string,\n          received: ctx2.parsedType\n        }\n      );\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch (_a) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"startsWith\") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _addCheck(check) {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this.min(len, message).max(len, message);\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodString.create = (params2) => {\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    ...processCreateParams(params2)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\");\n  }\n};\nZodNumber.create = (params2) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodBigInt = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.bigint,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBigInt.create = (params2) => {\n  return new ZodBigInt({\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params2) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodDate = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            minimum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            maximum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n};\nZodDate.create = (params2) => {\n  return new ZodDate({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params2) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params2) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params2) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params2) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = (params2) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params2) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodArray = class extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def2 = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def2.minLength !== null) {\n      if (ctx.data.length < def2.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def2.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          message: def2.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def2.maxLength !== null) {\n      if (ctx.data.length > def2.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def2.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          message: def2.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all(ctx.data.map((item, i) => {\n        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = ctx.data.map((item, i) => {\n      return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return this.min(len, message).max(len, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodArray.create = (schema2, params2) => {\n  return new ZodArray({\n    type: schema2,\n    minLength: null,\n    maxLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params2)\n  });\n};\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar AugmentFactory = (def2) => (augmentation) => {\n  return new ZodObject({\n    ...def2,\n    shape: () => ({\n      ...def2.shape(),\n      ...augmentation\n    })\n  });\n};\nfunction deepPartialify(schema2) {\n  if (schema2 instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema2.shape) {\n      const fieldSchema = schema2.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema2._def,\n      shape: () => newShape\n    });\n  } else if (schema2 instanceof ZodArray) {\n    return ZodArray.create(deepPartialify(schema2.element));\n  } else if (schema2 instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema2.unwrap()));\n  } else if (schema2 instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema2.unwrap()));\n  } else if (schema2 instanceof ZodTuple) {\n    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema2;\n  }\n}\nvar ZodObject = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = AugmentFactory(this._def);\n    this.extend = AugmentFactory(this._def);\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    return this._cached = { shape, keys };\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\")\n        ;\n      else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          syncPairs.push({\n            key,\n            value: await pair.value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          var _a, _b, _c, _d;\n          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n          if (issue.code === \"unrecognized_keys\")\n            return {\n              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  setKey(key, schema2) {\n    return this.augment({ [key]: schema2 });\n  }\n  merge(merging) {\n    const merged = new ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  catchall(index) {\n    return new ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    util.objectKeys(mask).map((key) => {\n      if (this.shape[key])\n        shape[key] = this.shape[key];\n    });\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    util.objectKeys(this.shape).map((key) => {\n      if (util.objectKeys(mask).indexOf(key) === -1) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    if (mask) {\n      util.objectKeys(this.shape).map((key) => {\n        if (util.objectKeys(mask).indexOf(key) === -1) {\n          newShape[key] = this.shape[key];\n        } else {\n          newShape[key] = this.shape[key].optional();\n        }\n      });\n      return new ZodObject({\n        ...this._def,\n        shape: () => newShape\n      });\n    } else {\n      for (const key in this.shape) {\n        const fieldSchema = this.shape[key];\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required() {\n    const newShape = {};\n    for (const key in this.shape) {\n      const fieldSchema = this.shape[key];\n      let newField = fieldSchema;\n      while (newField instanceof ZodOptional) {\n        newField = newField._def.innerType;\n      }\n      newShape[key] = newField;\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params2) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params2)\n  });\n};\nZodObject.strictCreate = (shape, params2) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params2)\n  });\n};\nZodObject.lazycreate = (shape, params2) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params2) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodDiscriminatedUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.options.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: this.validDiscriminatorValues,\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get validDiscriminatorValues() {\n    return Array.from(this.options.keys());\n  }\n  get options() {\n    return this._def.options;\n  }\n  static create(discriminator, types, params2) {\n    const options = /* @__PURE__ */ new Map();\n    try {\n      types.forEach((type) => {\n        const discriminatorValue = type.shape[discriminator].value;\n        options.set(discriminatorValue, type);\n      });\n    } catch (e) {\n      throw new Error(\"The discriminator value could not be extracted from all the provided schemas\");\n    }\n    if (options.size !== types.length) {\n      throw new Error(\"Some of the discriminator values are not unique\");\n    }\n    return new ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      ...processCreateParams(params2)\n    });\n  }\n};\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params2) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodTuple = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = ctx.data.map((item, itemIndex) => {\n      const schema2 = this._def.items[itemIndex] || this._def.rest;\n      if (!schema2)\n        return null;\n      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x) => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas2, params2) => {\n  if (!Array.isArray(schemas2)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas2,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodRecord = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params2) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodSet = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def2 = this._def;\n    if (def2.minSize !== null) {\n      if (ctx.data.size < def2.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def2.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          message: def2.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def2.maxSize !== null) {\n      if (ctx.data.size > def2.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def2.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          message: def2.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        if (element.status === \"dirty\")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodSet.create = (valueType, params2) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodFunction = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params2 = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      return OK(async (...args) => {\n        const error = new ZodError([]);\n        const parsedArgs = await this._def.args.parseAsync(args, params2).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await fn(...parsedArgs);\n        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params2).catch((e) => {\n          error.addIssue(makeReturnsIssue(result, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      return OK((...args) => {\n        const parsedArgs = this._def.args.safeParse(args, params2);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = fn(...parsedArgs.data);\n        const parsedReturns = this._def.returns.safeParse(result, params2);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params2) {\n    return new ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params2)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params2) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params2) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params2)\n  });\n};\nfunction createZodEnum(values, params2) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params2)\n  });\n}\nvar ZodEnum = class extends ZodType {\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (this._def.values.indexOf(input.data) === -1) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n};\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (nativeEnumValues.indexOf(input.data) === -1) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nZodNativeEnum.create = (values, params2) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema2, params2) => {\n  return new ZodPromise({\n    type: schema2,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then((processed2) => {\n          return this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n        });\n      } else {\n        return this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\")\n          return INVALID;\n        if (inner.status === \"dirty\")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\")\n            return INVALID;\n          if (inner.status === \"dirty\")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base3 = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base3))\n          return base3;\n        const result = effect.transform(base3.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {\n          if (!isValid(base3))\n            return base3;\n          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema2, effect, params2) => {\n  return new ZodEffects({\n    schema: schema2,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params2)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema2, params2) => {\n  return new ZodEffects({\n    schema: schema2,\n    effect: { type: \"preprocess\", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type, params2) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type, params2) => {\n  return new ZodNullable({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type, params2) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n};\nZodNaN.create = (params2) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params2)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar custom = (check, params2 = {}, fatal) => {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      if (!check(data)) {\n        const p = typeof params2 === \"function\" ? params2(data) : params2;\n        const p2 = typeof p === \"string\" ? { message: p } : p;\n        ctx.addIssue({ code: \"custom\", ...p2, fatal });\n      }\n    });\n  return ZodAny.create();\n};\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params2 = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params2, true);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar NEVER = INVALID;\nvar mod = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  getParsedType,\n  ZodParsedType,\n  defaultErrorMap: errorMap,\n  setErrorMap,\n  getErrorMap,\n  makeIssue,\n  EMPTY_PATH,\n  addIssueToContext,\n  ParseStatus,\n  INVALID,\n  DIRTY,\n  OK,\n  isAborted,\n  isDirty,\n  isValid,\n  isAsync,\n  ZodType,\n  ZodString,\n  ZodNumber,\n  ZodBigInt,\n  ZodBoolean,\n  ZodDate,\n  ZodUndefined,\n  ZodNull,\n  ZodAny,\n  ZodUnknown,\n  ZodNever,\n  ZodVoid,\n  ZodArray,\n  get objectUtil() {\n    return objectUtil;\n  },\n  ZodObject,\n  ZodUnion,\n  ZodDiscriminatedUnion,\n  ZodIntersection,\n  ZodTuple,\n  ZodRecord,\n  ZodMap,\n  ZodSet,\n  ZodFunction,\n  ZodLazy,\n  ZodLiteral,\n  ZodEnum,\n  ZodNativeEnum,\n  ZodPromise,\n  ZodEffects,\n  ZodTransformer: ZodEffects,\n  ZodOptional,\n  ZodNullable,\n  ZodDefault,\n  ZodNaN,\n  BRAND,\n  ZodBranded,\n  custom,\n  Schema: ZodType,\n  ZodSchema: ZodType,\n  late,\n  get ZodFirstPartyTypeKind() {\n    return ZodFirstPartyTypeKind;\n  },\n  any: anyType,\n  array: arrayType,\n  bigint: bigIntType,\n  boolean: booleanType,\n  date: dateType,\n  discriminatedUnion: discriminatedUnionType,\n  effect: effectsType,\n  \"enum\": enumType,\n  \"function\": functionType,\n  \"instanceof\": instanceOfType,\n  intersection: intersectionType,\n  lazy: lazyType,\n  literal: literalType,\n  map: mapType,\n  nan: nanType,\n  nativeEnum: nativeEnumType,\n  never: neverType,\n  \"null\": nullType,\n  nullable: nullableType,\n  number: numberType,\n  object: objectType,\n  oboolean,\n  onumber,\n  optional: optionalType,\n  ostring,\n  preprocess: preprocessType,\n  promise: promiseType,\n  record: recordType,\n  set: setType,\n  strictObject: strictObjectType,\n  string: stringType,\n  transformer: effectsType,\n  tuple: tupleType,\n  \"undefined\": undefinedType,\n  union: unionType,\n  unknown: unknownType,\n  \"void\": voidType,\n  NEVER,\n  ZodIssueCode,\n  quotelessJson,\n  ZodError\n});\n\n// ../common-web/src/types.ts\nvar cidSchema = mod.any().refine((obj) => CID.asCID(obj) !== null, {\n  message: \"Not a CID\"\n}).transform((obj) => CID.asCID(obj));\nvar schema = {\n  cid: cidSchema,\n  bytes: mod.instanceof(Uint8Array),\n  string: mod.string(),\n  array: mod.array(mod.unknown()),\n  map: mod.record(mod.string(), mod.unknown()),\n  unknown: mod.unknown()\n};\nvar def = {\n  cid: {\n    name: \"cid\",\n    schema: schema.cid\n  },\n  bytes: {\n    name: \"bytes\",\n    schema: schema.bytes\n  },\n  string: {\n    name: \"string\",\n    schema: schema.string\n  },\n  map: {\n    name: \"map\",\n    schema: schema.map\n  },\n  unknown: {\n    name: \"unknown\",\n    schema: schema.unknown\n  }\n};\n\n// ../common-web/src/times.ts\nvar SECOND = 1e3;\nvar MINUTE = SECOND * 60;\nvar HOUR = MINUTE * 60;\nvar DAY = HOUR * 24;\n\n// ../common-web/src/strings.ts\nvar utf8Len = (str) => {\n  return new TextEncoder().encode(str).byteLength;\n};\nvar graphemeLen = (str) => {\n  return [...new Intl.Segmenter().segment(str)].length;\n};\n\n// ../identifier/src/reserved.ts\nvar atpSpecific = [\n  \"at\",\n  \"atp\",\n  \"plc\",\n  \"pds\",\n  \"did\",\n  \"repo\",\n  \"tid\",\n  \"nsid\",\n  \"xrpc\",\n  \"lex\",\n  \"lexicon\",\n  \"bsky\",\n  \"bluesky\",\n  \"handle\"\n];\nvar commonlyReserved = [\n  \"about\",\n  \"abuse\",\n  \"access\",\n  \"account\",\n  \"accounts\",\n  \"acme\",\n  \"activate\",\n  \"activities\",\n  \"activity\",\n  \"ad\",\n  \"add\",\n  \"address\",\n  \"adm\",\n  \"admanager\",\n  \"admin\",\n  \"administration\",\n  \"administrator\",\n  \"administrators\",\n  \"admins\",\n  \"ads\",\n  \"adsense\",\n  \"adult\",\n  \"advertising\",\n  \"adwords\",\n  \"affiliate\",\n  \"affiliatepage\",\n  \"affiliates\",\n  \"afp\",\n  \"ajax\",\n  \"all\",\n  \"alpha\",\n  \"analysis\",\n  \"analytics\",\n  \"android\",\n  \"anon\",\n  \"anonymous\",\n  \"answer\",\n  \"answers\",\n  \"ap\",\n  \"api\",\n  \"apis\",\n  \"app\",\n  \"appengine\",\n  \"appnews\",\n  \"apps\",\n  \"archive\",\n  \"archives\",\n  \"article\",\n  \"asdf\",\n  \"asset\",\n  \"assets\",\n  \"auth\",\n  \"authentication\",\n  \"avatar\",\n  \"backup\",\n  \"bank\",\n  \"banner\",\n  \"banners\",\n  \"base\",\n  \"beginners\",\n  \"beta\",\n  \"billing\",\n  \"bin\",\n  \"binaries\",\n  \"binary\",\n  \"blackberry\",\n  \"blog\",\n  \"blogs\",\n  \"blogsearch\",\n  \"board\",\n  \"book\",\n  \"bookmark\",\n  \"bookmarks\",\n  \"books\",\n  \"bot\",\n  \"bots\",\n  \"bug\",\n  \"bugs\",\n  \"business\",\n  \"buy\",\n  \"buzz\",\n  \"cache\",\n  \"calendar\",\n  \"call\",\n  \"campaign\",\n  \"cancel\",\n  \"captcha\",\n  \"career\",\n  \"careers\",\n  \"cart\",\n  \"catalog\",\n  \"catalogs\",\n  \"categories\",\n  \"category\",\n  \"cdn\",\n  \"cgi\",\n  \"cgi-bin\",\n  \"changelog\",\n  \"chart\",\n  \"charts\",\n  \"chat\",\n  \"check\",\n  \"checked\",\n  \"checking\",\n  \"checkout\",\n  \"client\",\n  \"cliente\",\n  \"clients\",\n  \"clients1\",\n  \"cnarne\",\n  \"code\",\n  \"comercial\",\n  \"comment\",\n  \"comments\",\n  \"communities\",\n  \"community\",\n  \"company\",\n  \"compare\",\n  \"compras\",\n  \"config\",\n  \"configuration\",\n  \"confirm\",\n  \"confirmation\",\n  \"connect\",\n  \"contact\",\n  \"contacts\",\n  \"contactus\",\n  \"contact-us\",\n  \"contact_us\",\n  \"content\",\n  \"contest\",\n  \"contribute\",\n  \"contributor\",\n  \"contributors\",\n  \"coppa\",\n  \"copyright\",\n  \"copyrights\",\n  \"core\",\n  \"corp\",\n  \"countries\",\n  \"country\",\n  \"cpanel\",\n  \"create\",\n  \"css\",\n  \"cssproxy\",\n  \"customise\",\n  \"customize\",\n  \"dashboard\",\n  \"data\",\n  \"db\",\n  \"default\",\n  \"delete\",\n  \"demo\",\n  \"design\",\n  \"designer\",\n  \"desktop\",\n  \"destroy\",\n  \"dev\",\n  \"devel\",\n  \"developer\",\n  \"developers\",\n  \"devs\",\n  \"diagram\",\n  \"diary\",\n  \"dict\",\n  \"dictionary\",\n  \"die\",\n  \"dir\",\n  \"directory\",\n  \"direct_messages\",\n  \"direct-messages\",\n  \"dist\",\n  \"diversity\",\n  \"dl\",\n  \"dmca\",\n  \"doc\",\n  \"docs\",\n  \"documentation\",\n  \"documentations\",\n  \"documents\",\n  \"domain\",\n  \"domains\",\n  \"donate\",\n  \"download\",\n  \"downloads\",\n  \"e\",\n  \"e-mail\",\n  \"earth\",\n  \"ecommerce\",\n  \"edit\",\n  \"edits\",\n  \"editor\",\n  \"edu\",\n  \"education\",\n  \"email\",\n  \"embed\",\n  \"embedded\",\n  \"employment\",\n  \"employments\",\n  \"empty\",\n  \"enable\",\n  \"encrypted\",\n  \"end\",\n  \"engine\",\n  \"enterprise\",\n  \"enterprises\",\n  \"entries\",\n  \"entry\",\n  \"error\",\n  \"errorlog\",\n  \"errors\",\n  \"eval\",\n  \"event\",\n  \"example\",\n  \"examplecommunity\",\n  \"exampleopenid\",\n  \"examplesyn\",\n  \"examplesyndicated\",\n  \"exampleusername\",\n  \"exchange\",\n  \"exit\",\n  \"explore\",\n  \"faq\",\n  \"faqs\",\n  \"favorite\",\n  \"favorites\",\n  \"favourite\",\n  \"favourites\",\n  \"feature\",\n  \"features\",\n  \"feed\",\n  \"feedback\",\n  \"feedburner\",\n  \"feedproxy\",\n  \"feeds\",\n  \"file\",\n  \"files\",\n  \"finance\",\n  \"folder\",\n  \"folders\",\n  \"first\",\n  \"following\",\n  \"forgot\",\n  \"form\",\n  \"forms\",\n  \"forum\",\n  \"forums\",\n  \"founder\",\n  \"free\",\n  \"friend\",\n  \"friends\",\n  \"ftp\",\n  \"fuck\",\n  \"fun\",\n  \"fusion\",\n  \"gadget\",\n  \"gadgets\",\n  \"game\",\n  \"games\",\n  \"gears\",\n  \"general\",\n  \"geographic\",\n  \"get\",\n  \"gettingstarted\",\n  \"gift\",\n  \"gifts\",\n  \"gist\",\n  \"git\",\n  \"github\",\n  \"gmail\",\n  \"go\",\n  \"golang\",\n  \"goto\",\n  \"gov\",\n  \"graph\",\n  \"graphs\",\n  \"group\",\n  \"groups\",\n  \"guest\",\n  \"guests\",\n  \"guide\",\n  \"guides\",\n  \"hack\",\n  \"hacks\",\n  \"head\",\n  \"help\",\n  \"home\",\n  \"homepage\",\n  \"host\",\n  \"hosting\",\n  \"hostmaster\",\n  \"hostname\",\n  \"howto\",\n  \"how-to\",\n  \"how_to\",\n  \"html\",\n  \"htrnl\",\n  \"http\",\n  \"httpd\",\n  \"https\",\n  \"i\",\n  \"iamges\",\n  \"icon\",\n  \"icons\",\n  \"id\",\n  \"idea\",\n  \"ideas\",\n  \"im\",\n  \"image\",\n  \"images\",\n  \"img\",\n  \"imap\",\n  \"inbox\",\n  \"inboxes\",\n  \"index\",\n  \"indexes\",\n  \"info\",\n  \"information\",\n  \"inquiry\",\n  \"intranet\",\n  \"investor\",\n  \"investors\",\n  \"invitation\",\n  \"invitations\",\n  \"invite\",\n  \"invoice\",\n  \"invoices\",\n  \"imac\",\n  \"ios\",\n  \"ipad\",\n  \"iphone\",\n  \"irc\",\n  \"irnages\",\n  \"irng\",\n  \"is\",\n  \"issue\",\n  \"issues\",\n  \"it\",\n  \"item\",\n  \"items\",\n  \"java\",\n  \"javascript\",\n  \"job\",\n  \"jobs\",\n  \"join\",\n  \"js\",\n  \"json\",\n  \"jump\",\n  \"kb\",\n  \"knowledge-base\",\n  \"knowledgebase\",\n  \"lab\",\n  \"labs\",\n  \"language\",\n  \"languages\",\n  \"last\",\n  \"ldap_status\",\n  \"ldap-status\",\n  \"ldapstatus\",\n  \"legal\",\n  \"license\",\n  \"licenses\",\n  \"link\",\n  \"links\",\n  \"linux\",\n  \"list\",\n  \"lists\",\n  \"livejournal\",\n  \"lj\",\n  \"local\",\n  \"locale\",\n  \"location\",\n  \"log\",\n  \"log-in\",\n  \"log-out\",\n  \"login\",\n  \"logout\",\n  \"logs\",\n  \"log_in\",\n  \"log_out\",\n  \"m\",\n  \"mac\",\n  \"macos\",\n  \"macosx\",\n  \"mac-os\",\n  \"mac-os-x\",\n  \"mac_os_x\",\n  \"mail\",\n  \"mailer\",\n  \"mailing\",\n  \"main\",\n  \"maintenance\",\n  \"manage\",\n  \"manager\",\n  \"manual\",\n  \"map\",\n  \"maps\",\n  \"marketing\",\n  \"master\",\n  \"me\",\n  \"media\",\n  \"member\",\n  \"members\",\n  \"memories\",\n  \"memory\",\n  \"merchandise\",\n  \"message\",\n  \"messages\",\n  \"messenger\",\n  \"mg\",\n  \"microblog\",\n  \"microblogs\",\n  \"mine\",\n  \"mis\",\n  \"misc\",\n  \"mms\",\n  \"mob\",\n  \"mobile\",\n  \"model\",\n  \"models\",\n  \"money\",\n  \"movie\",\n  \"movies\",\n  \"mp3\",\n  \"mp4\",\n  \"msg\",\n  \"msn\",\n  \"music\",\n  \"mx\",\n  \"my\",\n  \"mymme\",\n  \"mysql\",\n  \"name\",\n  \"named\",\n  \"nan\",\n  \"navi\",\n  \"navigation\",\n  \"net\",\n  \"network\",\n  \"networks\",\n  \"new\",\n  \"news\",\n  \"newsletter\",\n  \"nick\",\n  \"nickname\",\n  \"nil\",\n  \"none\",\n  \"notes\",\n  \"noticias\",\n  \"notification\",\n  \"notifications\",\n  \"notify\",\n  \"ns\",\n  \"ns1\",\n  \"ns2\",\n  \"ns3\",\n  \"ns4\",\n  \"ns5\",\n  \"null\",\n  \"oauth\",\n  \"oauth-clients\",\n  \"oauth_clients\",\n  \"ocsp\",\n  \"offer\",\n  \"offers\",\n  \"official\",\n  \"old\",\n  \"online\",\n  \"openid\",\n  \"operator\",\n  \"option\",\n  \"options\",\n  \"order\",\n  \"orders\",\n  \"org\",\n  \"organization\",\n  \"organizations\",\n  \"other\",\n  \"overview\",\n  \"owner\",\n  \"owners\",\n  \"p0rn\",\n  \"pack\",\n  \"page\",\n  \"pager\",\n  \"pages\",\n  \"paid\",\n  \"panel\",\n  \"partner\",\n  \"partnerpage\",\n  \"partners\",\n  \"password\",\n  \"patch\",\n  \"pay\",\n  \"payment\",\n  \"people\",\n  \"perl\",\n  \"person\",\n  \"phone\",\n  \"photo\",\n  \"photoalbum\",\n  \"photos\",\n  \"php\",\n  \"phpmyadmin\",\n  \"phppgadmin\",\n  \"phpredisadmin\",\n  \"pic\",\n  \"pics\",\n  \"picture\",\n  \"pictures\",\n  \"ping\",\n  \"pixel\",\n  \"places\",\n  \"plan\",\n  \"plans\",\n  \"plugin\",\n  \"plugins\",\n  \"podcasts\",\n  \"policies\",\n  \"policy\",\n  \"pop\",\n  \"pop3\",\n  \"popular\",\n  \"porn\",\n  \"portal\",\n  \"portals\",\n  \"post\",\n  \"postfix\",\n  \"postmaster\",\n  \"posts\",\n  \"pr\",\n  \"pr0n\",\n  \"premium\",\n  \"press\",\n  \"price\",\n  \"pricing\",\n  \"principles\",\n  \"print\",\n  \"privacy\",\n  \"privacy-policy\",\n  \"privacypolicy\",\n  \"privacy_policy\",\n  \"private\",\n  \"prod\",\n  \"product\",\n  \"production\",\n  \"products\",\n  \"profile\",\n  \"profiles\",\n  \"project\",\n  \"projects\",\n  \"promo\",\n  \"promotions\",\n  \"proxies\",\n  \"proxy\",\n  \"pub\",\n  \"public\",\n  \"purchase\",\n  \"purpose\",\n  \"put\",\n  \"python\",\n  \"queries\",\n  \"query\",\n  \"radio\",\n  \"random\",\n  \"ranking\",\n  \"read\",\n  \"reader\",\n  \"readme\",\n  \"recent\",\n  \"recruit\",\n  \"recruitment\",\n  \"redirect\",\n  \"register\",\n  \"registration\",\n  \"release\",\n  \"remove\",\n  \"replies\",\n  \"report\",\n  \"reports\",\n  \"repositories\",\n  \"repository\",\n  \"req\",\n  \"request\",\n  \"requests\",\n  \"research\",\n  \"reset\",\n  \"resolve\",\n  \"resolver\",\n  \"review\",\n  \"rnail\",\n  \"rnicrosoft\",\n  \"roc\",\n  \"root\",\n  \"rss\",\n  \"ruby\",\n  \"rule\",\n  \"sag\",\n  \"sale\",\n  \"sales\",\n  \"sample\",\n  \"samples\",\n  \"sandbox\",\n  \"save\",\n  \"scholar\",\n  \"school\",\n  \"schools\",\n  \"script\",\n  \"scripts\",\n  \"search\",\n  \"secure\",\n  \"security\",\n  \"self\",\n  \"seminars\",\n  \"send\",\n  \"server\",\n  \"server-info\",\n  \"server_info\",\n  \"server-status\",\n  \"server_status\",\n  \"servers\",\n  \"service\",\n  \"services\",\n  \"session\",\n  \"sessions\",\n  \"setting\",\n  \"settings\",\n  \"setup\",\n  \"share\",\n  \"shop\",\n  \"shopping\",\n  \"shortcut\",\n  \"shortcuts\",\n  \"show\",\n  \"sign-in\",\n  \"sign-up\",\n  \"signin\",\n  \"signout\",\n  \"signup\",\n  \"sign_in\",\n  \"sign_up\",\n  \"site\",\n  \"sitemap\",\n  \"sitemaps\",\n  \"sitenews\",\n  \"sites\",\n  \"sketchup\",\n  \"sky\",\n  \"slash\",\n  \"slashinvoice\",\n  \"slut\",\n  \"smartphone\",\n  \"sms\",\n  \"smtp\",\n  \"soap\",\n  \"software\",\n  \"sorry\",\n  \"source\",\n  \"spec\",\n  \"special\",\n  \"spreadsheet\",\n  \"spreadsheets\",\n  \"sql\",\n  \"src\",\n  \"srntp\",\n  \"ssh\",\n  \"ssl\",\n  \"ssladmin\",\n  \"ssladministrator\",\n  \"sslwebmaster\",\n  \"ssytem\",\n  \"staff\",\n  \"stage\",\n  \"staging\",\n  \"start\",\n  \"stat\",\n  \"state\",\n  \"static\",\n  \"statistics\",\n  \"stats\",\n  \"status\",\n  \"store\",\n  \"stores\",\n  \"stories\",\n  \"style\",\n  \"styleguide\",\n  \"styles\",\n  \"stylesheet\",\n  \"stylesheets\",\n  \"subdomain\",\n  \"subscribe\",\n  \"subscription\",\n  \"subscriptions\",\n  \"suggest\",\n  \"suggestqueries\",\n  \"support\",\n  \"survey\",\n  \"surveys\",\n  \"surveytool\",\n  \"svn\",\n  \"swf\",\n  \"syn\",\n  \"sync\",\n  \"syndicated\",\n  \"sys\",\n  \"sysadmin\",\n  \"sysadministrator\",\n  \"sysadmins\",\n  \"system\",\n  \"tablet\",\n  \"tablets\",\n  \"tag\",\n  \"tags\",\n  \"talk\",\n  \"talkgadget\",\n  \"task\",\n  \"tasks\",\n  \"team\",\n  \"teams\",\n  \"tech\",\n  \"telnet\",\n  \"term\",\n  \"terms\",\n  \"terms-of-service\",\n  \"termsofservice\",\n  \"terms_of_service\",\n  \"test\",\n  \"testing\",\n  \"tests\",\n  \"text\",\n  \"theme\",\n  \"themes\",\n  \"thread\",\n  \"threads\",\n  \"ticket\",\n  \"tickets\",\n  \"tmp\",\n  \"todo\",\n  \"to-do\",\n  \"to_do\",\n  \"toml\",\n  \"tool\",\n  \"toolbar\",\n  \"toolbars\",\n  \"tools\",\n  \"top\",\n  \"topic\",\n  \"topics\",\n  \"tos\",\n  \"tour\",\n  \"trac\",\n  \"translate\",\n  \"trace\",\n  \"translation\",\n  \"translations\",\n  \"translator\",\n  \"trends\",\n  \"tutorial\",\n  \"tux\",\n  \"tv\",\n  \"twitter\",\n  \"txt\",\n  \"ul\",\n  \"undef\",\n  \"unfollow\",\n  \"unsubscribe\",\n  \"update\",\n  \"updates\",\n  \"upgrade\",\n  \"upgrades\",\n  \"upi\",\n  \"upload\",\n  \"uploads\",\n  \"url\",\n  \"usage\",\n  \"user\",\n  \"username\",\n  \"usernames\",\n  \"users\",\n  \"uuid\",\n  \"validation\",\n  \"validations\",\n  \"ver\",\n  \"version\",\n  \"video\",\n  \"videos\",\n  \"video-stats\",\n  \"visitor\",\n  \"visitors\",\n  \"voice\",\n  \"volunteer\",\n  \"volunteers\",\n  \"w\",\n  \"watch\",\n  \"wave\",\n  \"weather\",\n  \"web\",\n  \"webdisk\",\n  \"webhook\",\n  \"webhooks\",\n  \"webmail\",\n  \"webmaster\",\n  \"webmasters\",\n  \"webrnail\",\n  \"website\",\n  \"websites\",\n  \"welcome\",\n  \"whm\",\n  \"whois\",\n  \"widget\",\n  \"widgets\",\n  \"wifi\",\n  \"wiki\",\n  \"wikis\",\n  \"win\",\n  \"windows\",\n  \"word\",\n  \"work\",\n  \"works\",\n  \"workshop\",\n  \"wpad\",\n  \"ww\",\n  \"wws\",\n  \"www\",\n  \"wwws\",\n  \"wwww\",\n  \"xfn\",\n  \"xhtml\",\n  \"xhtrnl\",\n  \"xml\",\n  \"xmpp\",\n  \"xpg\",\n  \"xxx\",\n  \"yaml\",\n  \"year\",\n  \"yml\",\n  \"you\",\n  \"yourdomain\",\n  \"yourname\",\n  \"yoursite\",\n  \"yourusername\"\n];\nvar famousAccounts = [\n  \"10ronaldinho\",\n  \"3gerardpique\",\n  \"adele\",\n  \"akshaykumar\",\n  \"aliaa08\",\n  \"aliciakeys\",\n  \"amitshah\",\n  \"andresiniesta8\",\n  \"anushkasharma\",\n  \"arianagrande\",\n  \"arrahman\",\n  \"arvindkejriwal\",\n  \"avrillavigne\",\n  \"barackobama\",\n  \"bbcbreaking\",\n  \"bbcworld\",\n  \"beingsalmankhan\",\n  \"billgates\",\n  \"britneyspears\",\n  \"brunomars\",\n  \"bts_bighit\",\n  \"bts_twt\",\n  \"championsleague\",\n  \"chrisbrown\",\n  \"cnnbrk\",\n  \"coldplay\",\n  \"conanobrien\",\n  \"cristiano\",\n  \"danieltosh\",\n  \"davidguetta\",\n  \"ddlovato\",\n  \"deepikapadukone\",\n  \"drake\",\n  \"elisapie\",\n  \"ellendegeneres\",\n  \"elonmusk\",\n  \"eminem\",\n  \"emmawatson\",\n  \"fcbarcelona\",\n  \"foxnews\",\n  \"harry_styles\",\n  \"hillaryclinton\",\n  \"iamsrk\",\n  \"ihrithik\",\n  \"imvkohli\",\n  \"instagram\",\n  \"jimmyfallon\",\n  \"jlo\",\n  \"joebiden\",\n  \"jtimberlake\",\n  \"justinbieber\",\n  \"kaka\",\n  \"kanyewest\",\n  \"katyperry\",\n  \"kendalljenner\",\n  \"kevinhart4real\",\n  \"khloekardashian\",\n  \"kimkardashian\",\n  \"kingjames\",\n  \"kourtneykardash\",\n  \"kyliejenner\",\n  \"ladygaga\",\n  \"liampayne\",\n  \"liltunechi\",\n  \"manutd\",\n  \"mariahcarey\",\n  \"mileycyrus\",\n  \"mohamadalarefe\",\n  \"narendramodi\",\n  \"nasa\",\n  \"nba\",\n  \"neymarjr\",\n  \"nfl\",\n  \"niallofficial\",\n  \"nickiminaj\",\n  \"npr\",\n  \"nytimes\",\n  \"onedirection\",\n  \"oprah\",\n  \"pink\",\n  \"pitbull\",\n  \"playstation\",\n  \"pmoindia\",\n  \"premierleague\",\n  \"priyankachopra\",\n  \"realdonaldtrump\",\n  \"ricky_martin\",\n  \"rihanna\",\n  \"sachin_rt\",\n  \"selenagomez\",\n  \"shakira\",\n  \"shawnmendes\",\n  \"sportscenter\",\n  \"srbachchan\",\n  \"subhisharma100\",\n  \"taylorswift13\",\n  \"theeconomist\",\n  \"twitter\",\n  \"virendersehwag\",\n  \"whitehouse45\",\n  \"wizkhalifa\",\n  \"youtube\",\n  \"zaynmalik\",\n  \"beyonce\",\n  \"billieeilish\",\n  \"leomessi\",\n  \"natgeo\",\n  \"nike\",\n  \"snoopdogg\",\n  \"taylorswift\",\n  \"therock\",\n  \"10downingstreet\",\n  \"aoc\",\n  \"carterjwm\",\n  \"dril\",\n  \"gretathunberg\",\n  \"kamalaharris\",\n  \"kremlinrussia_e\",\n  \"potus\",\n  \"rondesantisfl\",\n  \"ukraine\",\n  \"washingtonpost\",\n  \"yousuck2020\",\n  \"zelenskyyua\",\n  \"akiko_lawson\",\n  \"ariyoshihiroiki\",\n  \"asahi\",\n  \"dozle_official\",\n  \"famima_now\",\n  \"ff_xiv_jp\",\n  \"fujitv\",\n  \"gigazine\",\n  \"hajimesyacho\",\n  \"hikakin\",\n  \"jocx\",\n  \"jotx\",\n  \"kiyo_saiore\",\n  \"mainichi\",\n  \"matsu_bouzu\",\n  \"naomiosaka\",\n  \"nhk\",\n  \"nikkei\",\n  \"nintendo\",\n  \"ntv\",\n  \"oowareware1945\",\n  \"pamyurin\",\n  \"poke_times\",\n  \"rolaworld\",\n  \"seikintv\",\n  \"starbucksjapan\",\n  \"tbs\",\n  \"tbs_pr\",\n  \"tvasahi\",\n  \"tvtokyo\",\n  \"yokoono\",\n  \"yomiuri_online\",\n  \"brasildefato\",\n  \"claudialeitte\",\n  \"correio\",\n  \"em_com\",\n  \"estadao\",\n  \"folha\",\n  \"gazetadopovo\",\n  \"ivetesangalo\",\n  \"jairbolsonaro\",\n  \"jornaldobrasil\",\n  \"jornaloglobo\",\n  \"lucianohuck\",\n  \"lulaoficial\",\n  \"marcosmion\",\n  \"paulocoelho\",\n  \"portalr7\",\n  \"rede_globo\",\n  \"zerohora\"\n];\nvar reservedSubdomains = [\n  ...atpSpecific,\n  ...commonlyReserved,\n  ...famousAccounts\n].reduce((acc, cur) => {\n  return {\n    ...acc,\n    [cur]: true\n  };\n}, {});\n\n// ../identifier/src/handle.ts\nvar ensureValidHandle = (handle2) => {\n  if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {\n    throw new InvalidHandleError(\n      \"Disallowed characters in handle (ASCII letters, digits, dashes, periods only)\"\n    );\n  }\n  if (handle2.length > 253) {\n    throw new InvalidHandleError(\"Handle is too long (253 chars max)\");\n  }\n  const labels = handle2.split(\".\");\n  if (labels.length < 2) {\n    throw new InvalidHandleError(\"Handle domain needs at least two parts\");\n  }\n  for (let i = 0; i < labels.length; i++) {\n    const l = labels[i];\n    if (l.length < 1) {\n      throw new InvalidHandleError(\"Handle parts can not be empty\");\n    }\n    if (l.length > 63) {\n      throw new InvalidHandleError(\"Handle part too long (max 63 chars)\");\n    }\n    if (l.endsWith(\"-\") || l.startsWith(\"-\")) {\n      throw new InvalidHandleError(\n        \"Handle parts can not start or end with hyphens\"\n      );\n    }\n    if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {\n      throw new InvalidHandleError(\n        \"Handle final component (TLD) must start with ASCII letter\"\n      );\n    }\n  }\n};\nvar InvalidHandleError = class extends Error {\n};\n\n// ../identifier/src/did.ts\nvar ensureValidDid = (did2) => {\n  if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {\n    throw new InvalidDidError(\n      \"Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)\"\n    );\n  }\n  const parts = did2.split(\":\");\n  if (parts.length < 3) {\n    throw new InvalidDidError(\n      \"DID requires prefix, method, and method-specific content\"\n    );\n  }\n  if (parts[0] != \"did\") {\n    throw new InvalidDidError('DID requires \"did:\" prefix');\n  }\n  if (!/^[a-z]+$/.test(parts[1])) {\n    throw new InvalidDidError(\"DID method must be lower-case letters\");\n  }\n  if (did2.endsWith(\":\") || did2.endsWith(\"%\")) {\n    throw new InvalidDidError('DID can not end with \":\" or \"%\"');\n  }\n  if (did2.length > 8 * 1024) {\n    throw new InvalidDidError(\"DID is far too long\");\n  }\n};\nvar InvalidDidError = class extends Error {\n};\n\n// ../nsid/src/index.ts\nvar NSID = class {\n  constructor(nsid2) {\n    this.segments = [];\n    ensureValidNsid(nsid2);\n    this.segments = nsid2.split(\".\");\n  }\n  static parse(nsid2) {\n    return new NSID(nsid2);\n  }\n  static create(authority, name2) {\n    const segments = [...authority.split(\".\").reverse(), name2].join(\".\");\n    return new NSID(segments);\n  }\n  static isValid(nsid2) {\n    try {\n      NSID.parse(nsid2);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  get authority() {\n    return this.segments.slice(0, this.segments.length - 1).reverse().join(\".\");\n  }\n  get name() {\n    return this.segments.at(this.segments.length - 1);\n  }\n  toString() {\n    return this.segments.join(\".\");\n  }\n};\nvar ensureValidNsid = (nsid2) => {\n  const split = nsid2.split(\".\");\n  const toCheck = split.at(-1) === \"*\" ? split.slice(0, -1).join(\".\") : split.join(\".\");\n  if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {\n    throw new InvalidNsidError(\n      \"Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)\"\n    );\n  }\n  if (toCheck.length > 253 + 1 + 128) {\n    throw new InvalidNsidError(\"NSID is too long (382 chars max)\");\n  }\n  const labels = toCheck.split(\".\");\n  if (split.length < 3) {\n    throw new InvalidNsidError(\"NSID needs at least three parts\");\n  }\n  for (let i = 0; i < labels.length; i++) {\n    const l = labels[i];\n    if (l.length < 1) {\n      throw new InvalidNsidError(\"NSID parts can not be empty\");\n    }\n    if (l.length > 63 && i + 1 < labels.length) {\n      throw new InvalidNsidError(\"NSID domain part too long (max 63 chars)\");\n    }\n    if (l.length > 128 && i + 1 == labels.length) {\n      throw new InvalidNsidError(\"NSID name part too long (max 127 chars)\");\n    }\n    if (l.endsWith(\"-\")) {\n      throw new InvalidNsidError(\"NSID parts can not end with hyphen\");\n    }\n    if (!/^[a-zA-Z]/.test(l)) {\n      throw new InvalidNsidError(\"NSID parts must start with ASCII letter\");\n    }\n  }\n};\nvar InvalidNsidError = class extends Error {\n};\n\n// ../uri/src/validation.ts\nvar ensureValidAtUri = (uri2) => {\n  const uriParts = uri2.split(\"#\");\n  if (uriParts.length > 2) {\n    throw new Error('ATURI can have at most one \"#\", separating fragment out');\n  }\n  const fragmentPart = uriParts[1] || null;\n  uri2 = uriParts[0];\n  if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri2)) {\n    throw new Error(\"Disallowed characters in ATURI (ASCII)\");\n  }\n  const parts = uri2.split(\"/\");\n  if (parts.length >= 3 && (parts[0] != \"at:\" || parts[1].length != 0)) {\n    throw new Error('ATURI must start with \"at://\"');\n  }\n  if (parts.length < 3) {\n    throw new Error(\"ATURI requires at least method and authority sections\");\n  }\n  try {\n    ensureValidHandle(parts[2]);\n  } catch {\n    try {\n      ensureValidDid(parts[2]);\n    } catch {\n      throw new Error(\"ATURI authority must be a valid handle or DID\");\n    }\n  }\n  if (parts.length >= 4) {\n    if (parts[3].length == 0) {\n      throw new Error(\n        \"ATURI can not have a slash after authority without a path segment\"\n      );\n    }\n    try {\n      ensureValidNsid(parts[3]);\n    } catch {\n      throw new Error(\n        \"ATURI requires first path segment (if supplied) to be valid NSID\"\n      );\n    }\n  }\n  if (parts.length >= 5) {\n    if (parts[4].length == 0) {\n      throw new Error(\n        \"ATURI can not have a slash after collection, unless record key is provided\"\n      );\n    }\n  }\n  if (parts.length >= 6) {\n    throw new Error(\n      \"ATURI path can have at most two parts, and no trailing slash\"\n    );\n  }\n  if (uriParts.length >= 2 && fragmentPart == null) {\n    throw new Error(\"ATURI fragment must be non-empty and start with slash\");\n  }\n  if (fragmentPart != null) {\n    if (fragmentPart.length == 0 || fragmentPart[0] != \"/\") {\n      throw new Error(\"ATURI fragment must be non-empty and start with slash\");\n    }\n    if (!/^\\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\\]/-]*$/.test(fragmentPart)) {\n      throw new Error(\"Disallowed characters in ATURI fragment (ASCII)\");\n    }\n  }\n  if (uri2.length > 8 * 1024) {\n    throw new Error(\"ATURI is far too long\");\n  }\n};\n\n// ../uri/src/index.ts\nvar ATP_URI_REGEX = /^(at:\\/\\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\\/[^?#\\s]*)?(\\?[^#\\s]+)?(#[^\\s]+)?$/i;\nvar RELATIVE_REGEX = /^(\\/[^?#\\s]*)?(\\?[^#\\s]+)?(#[^\\s]+)?$/i;\nvar AtUri = class {\n  constructor(uri2, base3) {\n    let parsed;\n    if (base3) {\n      parsed = parse(base3);\n      if (!parsed) {\n        throw new Error(`Invalid at uri: ${base3}`);\n      }\n      const relativep = parseRelative(uri2);\n      if (!relativep) {\n        throw new Error(`Invalid path: ${uri2}`);\n      }\n      Object.assign(parsed, relativep);\n    } else {\n      parsed = parse(uri2);\n      if (!parsed) {\n        throw new Error(`Invalid at uri: ${uri2}`);\n      }\n    }\n    this.hash = parsed.hash;\n    this.host = parsed.host;\n    this.pathname = parsed.pathname;\n    this.searchParams = parsed.searchParams;\n  }\n  static make(handleOrDid, collection, rkey) {\n    let str = handleOrDid;\n    if (collection)\n      str += \"/\" + collection;\n    if (rkey)\n      str += \"/\" + rkey;\n    return new AtUri(str);\n  }\n  get protocol() {\n    return \"at:\";\n  }\n  get origin() {\n    return `at://${this.host}`;\n  }\n  get hostname() {\n    return this.host;\n  }\n  set hostname(v) {\n    this.host = v;\n  }\n  get search() {\n    return this.searchParams.toString();\n  }\n  set search(v) {\n    this.searchParams = new URLSearchParams(v);\n  }\n  get collection() {\n    return this.pathname.split(\"/\").filter(Boolean)[0] || \"\";\n  }\n  set collection(v) {\n    const parts = this.pathname.split(\"/\").filter(Boolean);\n    parts[0] = v;\n    this.pathname = parts.join(\"/\");\n  }\n  get rkey() {\n    return this.pathname.split(\"/\").filter(Boolean)[1] || \"\";\n  }\n  set rkey(v) {\n    const parts = this.pathname.split(\"/\").filter(Boolean);\n    if (!parts[0])\n      parts[0] = \"undefined\";\n    parts[1] = v;\n    this.pathname = parts.join(\"/\");\n  }\n  get href() {\n    return this.toString();\n  }\n  toString() {\n    let path = this.pathname || \"/\";\n    if (!path.startsWith(\"/\")) {\n      path = `/${path}`;\n    }\n    let qs = this.searchParams.toString();\n    if (qs && !qs.startsWith(\"?\")) {\n      qs = `?${qs}`;\n    }\n    let hash = this.hash;\n    if (hash && !hash.startsWith(\"#\")) {\n      hash = `#${hash}`;\n    }\n    return `at://${this.host}${path}${qs}${hash}`;\n  }\n};\nfunction parse(str) {\n  const match = ATP_URI_REGEX.exec(str);\n  if (match) {\n    return {\n      hash: match[5] || \"\",\n      host: match[2] || \"\",\n      pathname: match[3] || \"\",\n      searchParams: new URLSearchParams(match[4] || \"\")\n    };\n  }\n  return void 0;\n}\nfunction parseRelative(str) {\n  const match = RELATIVE_REGEX.exec(str);\n  if (match) {\n    return {\n      hash: match[3] || \"\",\n      pathname: match[1] || \"\",\n      searchParams: new URLSearchParams(match[2] || \"\")\n    };\n  }\n  return void 0;\n}\n\n// ../lexicon/src/types.ts\nvar lexBoolean = mod.object({\n  type: mod.literal(\"boolean\"),\n  description: mod.string().optional(),\n  default: mod.boolean().optional(),\n  const: mod.boolean().optional()\n});\nvar lexInteger = mod.object({\n  type: mod.literal(\"integer\"),\n  description: mod.string().optional(),\n  default: mod.number().int().optional(),\n  minimum: mod.number().int().optional(),\n  maximum: mod.number().int().optional(),\n  enum: mod.number().int().array().optional(),\n  const: mod.number().int().optional()\n});\nvar lexStringFormat = mod.enum([\n  \"datetime\",\n  \"uri\",\n  \"at-uri\",\n  \"did\",\n  \"handle\",\n  \"at-identifier\",\n  \"nsid\",\n  \"cid\"\n]);\nvar lexString = mod.object({\n  type: mod.literal(\"string\"),\n  format: lexStringFormat.optional(),\n  description: mod.string().optional(),\n  default: mod.string().optional(),\n  minLength: mod.number().int().optional(),\n  maxLength: mod.number().int().optional(),\n  minGraphemes: mod.number().int().optional(),\n  maxGraphemes: mod.number().int().optional(),\n  enum: mod.string().array().optional(),\n  const: mod.string().optional(),\n  knownValues: mod.string().array().optional()\n});\nvar lexUnknown = mod.object({\n  type: mod.literal(\"unknown\"),\n  description: mod.string().optional()\n});\nvar lexPrimitive = mod.union([\n  lexBoolean,\n  lexInteger,\n  lexString,\n  lexUnknown\n]);\nvar lexBytes = mod.object({\n  type: mod.literal(\"bytes\"),\n  description: mod.string().optional(),\n  maxLength: mod.number().optional(),\n  minLength: mod.number().optional()\n});\nvar lexCidLink = mod.object({\n  type: mod.literal(\"cid-link\"),\n  description: mod.string().optional()\n});\nvar lexIpldType = mod.union([lexBytes, lexCidLink]);\nvar lexRef = mod.object({\n  type: mod.literal(\"ref\"),\n  description: mod.string().optional(),\n  ref: mod.string()\n});\nvar lexRefUnion = mod.object({\n  type: mod.literal(\"union\"),\n  description: mod.string().optional(),\n  refs: mod.string().array(),\n  closed: mod.boolean().optional()\n});\nvar lexRefVariant = mod.union([lexRef, lexRefUnion]);\nvar lexBlob = mod.object({\n  type: mod.literal(\"blob\"),\n  description: mod.string().optional(),\n  accept: mod.string().array().optional(),\n  maxSize: mod.number().optional()\n});\nvar lexArray = mod.object({\n  type: mod.literal(\"array\"),\n  description: mod.string().optional(),\n  items: mod.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),\n  minLength: mod.number().int().optional(),\n  maxLength: mod.number().int().optional()\n});\nvar lexPrimitiveArray = lexArray.merge(\n  mod.object({\n    items: lexPrimitive\n  })\n);\nvar lexToken = mod.object({\n  type: mod.literal(\"token\"),\n  description: mod.string().optional()\n});\nvar lexObject = mod.object({\n  type: mod.literal(\"object\"),\n  description: mod.string().optional(),\n  required: mod.string().array().optional(),\n  nullable: mod.string().array().optional(),\n  properties: mod.record(\n    mod.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive])\n  ).optional()\n});\nvar lexXrpcParameters = mod.object({\n  type: mod.literal(\"params\"),\n  description: mod.string().optional(),\n  required: mod.string().array().optional(),\n  properties: mod.record(mod.union([lexPrimitive, lexPrimitiveArray]))\n});\nvar lexXrpcBody = mod.object({\n  description: mod.string().optional(),\n  encoding: mod.string(),\n  schema: mod.union([lexRefVariant, lexObject]).optional()\n});\nvar lexXrpcSubscriptionMessage = mod.object({\n  description: mod.string().optional(),\n  schema: mod.union([lexRefVariant, lexObject]).optional()\n});\nvar lexXrpcError = mod.object({\n  name: mod.string(),\n  description: mod.string().optional()\n});\nvar lexXrpcQuery = mod.object({\n  type: mod.literal(\"query\"),\n  description: mod.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  output: lexXrpcBody.optional(),\n  errors: lexXrpcError.array().optional()\n});\nvar lexXrpcProcedure = mod.object({\n  type: mod.literal(\"procedure\"),\n  description: mod.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  input: lexXrpcBody.optional(),\n  output: lexXrpcBody.optional(),\n  errors: lexXrpcError.array().optional()\n});\nvar lexXrpcSubscription = mod.object({\n  type: mod.literal(\"subscription\"),\n  description: mod.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  message: lexXrpcSubscriptionMessage.optional(),\n  infos: lexXrpcError.array().optional(),\n  errors: lexXrpcError.array().optional()\n});\nvar lexRecord = mod.object({\n  type: mod.literal(\"record\"),\n  description: mod.string().optional(),\n  key: mod.string().optional(),\n  record: lexObject\n});\nvar lexUserType = mod.union([\n  lexRecord,\n  lexXrpcQuery,\n  lexXrpcProcedure,\n  lexXrpcSubscription,\n  lexBlob,\n  lexArray,\n  lexToken,\n  lexObject,\n  lexBoolean,\n  lexInteger,\n  lexString,\n  lexBytes,\n  lexCidLink,\n  lexUnknown\n]);\nvar lexiconDoc = mod.object({\n  lexicon: mod.literal(1),\n  id: mod.string().refine((v) => NSID.isValid(v), {\n    message: \"Must be a valid NSID\"\n  }),\n  revision: mod.number().optional(),\n  description: mod.string().optional(),\n  defs: mod.record(lexUserType)\n}).superRefine((doc, ctx) => {\n  for (const defId in doc.defs) {\n    const def2 = doc.defs[defId];\n    if (defId !== \"main\" && (def2.type === \"record\" || def2.type === \"procedure\" || def2.type === \"query\" || def2.type === \"subscription\")) {\n      ctx.addIssue({\n        code: mod.ZodIssueCode.custom,\n        message: `Records, procedures, queries, and subscriptions must be the main definition.`\n      });\n    }\n  }\n});\nfunction isObj(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\nfunction hasProp(data, prop) {\n  return prop in data;\n}\nvar discriminatedObject = mod.object({ $type: mod.string() });\nfunction isDiscriminatedObject(value) {\n  return discriminatedObject.safeParse(value).success;\n}\nvar LexiconDocMalformedError = class extends Error {\n  constructor(message, schemaDef, issues) {\n    super(message);\n    this.schemaDef = schemaDef;\n    this.issues = issues;\n    this.schemaDef = schemaDef;\n    this.issues = issues;\n  }\n};\nvar ValidationError = class extends Error {\n};\nvar InvalidLexiconError = class extends Error {\n};\nvar LexiconDefNotFoundError = class extends Error {\n};\n\n// ../lexicon/src/validators/formats.ts\nvar import_iso_datestring_validator = __toESM(require_dist());\nfunction datetime(path, value) {\n  try {\n    if (!(0, import_iso_datestring_validator.isValidISODateString)(value)) {\n      throw new Error();\n    }\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(\n        `${path} must be an iso8601 formatted datetime`\n      )\n    };\n  }\n  return { success: true, value };\n}\nfunction uri(path, value) {\n  const isUri = value.match(/^\\w+:(?:\\/\\/)?[^\\s/][^\\s]*$/) !== null;\n  if (!isUri) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a uri`)\n    };\n  }\n  return { success: true, value };\n}\nfunction atUri(path, value) {\n  try {\n    ensureValidAtUri(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid at-uri`)\n    };\n  }\n  return { success: true, value };\n}\nfunction did(path, value) {\n  try {\n    ensureValidDid(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid did`)\n    };\n  }\n  return { success: true, value };\n}\nfunction handle(path, value) {\n  try {\n    ensureValidHandle(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid handle`)\n    };\n  }\n  return { success: true, value };\n}\nfunction atIdentifier(path, value) {\n  const isDid = did(path, value);\n  if (!isDid.success) {\n    const isHandle2 = handle(path, value);\n    if (!isHandle2.success) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be a valid did or a handle`)\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction nsid(path, value) {\n  try {\n    ensureValidNsid(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid nsid`)\n    };\n  }\n  return { success: true, value };\n}\nfunction cid(path, value) {\n  try {\n    CID.parse(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a cid string`)\n    };\n  }\n  return { success: true, value };\n}\n\n// ../lexicon/src/validators/primitives.ts\nfunction validate(lexicons2, path, def2, value) {\n  switch (def2.type) {\n    case \"boolean\":\n      return boolean(lexicons2, path, def2, value);\n    case \"integer\":\n      return integer(lexicons2, path, def2, value);\n    case \"string\":\n      return string2(lexicons2, path, def2, value);\n    case \"bytes\":\n      return bytes(lexicons2, path, def2, value);\n    case \"cid-link\":\n      return cidLink(lexicons2, path, def2, value);\n    case \"unknown\":\n      return unknown(lexicons2, path, def2, value);\n    default:\n      return {\n        success: false,\n        error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)\n      };\n  }\n}\nfunction boolean(lexicons2, path, def2, value) {\n  def2 = def2;\n  const type = typeof value;\n  if (type === \"undefined\") {\n    if (typeof def2.default === \"boolean\") {\n      return { success: true, value: def2.default };\n    }\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a boolean`)\n    };\n  } else if (type !== \"boolean\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a boolean`)\n    };\n  }\n  if (typeof def2.const === \"boolean\") {\n    if (value !== def2.const) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be ${def2.const}`)\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction integer(lexicons2, path, def2, value) {\n  def2 = def2;\n  const type = typeof value;\n  if (type === \"undefined\") {\n    if (typeof def2.default === \"number\") {\n      return { success: true, value: def2.default };\n    }\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an integer`)\n    };\n  } else if (!Number.isInteger(value)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an integer`)\n    };\n  }\n  if (typeof def2.const === \"number\") {\n    if (value !== def2.const) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be ${def2.const}`)\n      };\n    }\n  }\n  if (Array.isArray(def2.enum)) {\n    if (!def2.enum.includes(value)) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must be one of (${def2.enum.join(\"|\")})`\n        )\n      };\n    }\n  }\n  if (typeof def2.maximum === \"number\") {\n    if (value > def2.maximum) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} can not be greater than ${def2.maximum}`\n        )\n      };\n    }\n  }\n  if (typeof def2.minimum === \"number\") {\n    if (value < def2.minimum) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} can not be less than ${def2.minimum}`\n        )\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction string2(lexicons2, path, def2, value) {\n  def2 = def2;\n  if (typeof value === \"undefined\") {\n    if (typeof def2.default === \"string\") {\n      return { success: true, value: def2.default };\n    }\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a string`)\n    };\n  } else if (typeof value !== \"string\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a string`)\n    };\n  }\n  if (typeof def2.const === \"string\") {\n    if (value !== def2.const) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be ${def2.const}`)\n      };\n    }\n  }\n  if (Array.isArray(def2.enum)) {\n    if (!def2.enum.includes(value)) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must be one of (${def2.enum.join(\"|\")})`\n        )\n      };\n    }\n  }\n  if (typeof def2.maxLength === \"number\") {\n    if (utf8Len(value) > def2.maxLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be longer than ${def2.maxLength} characters`\n        )\n      };\n    }\n  }\n  if (typeof def2.minLength === \"number\") {\n    if (utf8Len(value) < def2.minLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be shorter than ${def2.minLength} characters`\n        )\n      };\n    }\n  }\n  if (typeof def2.maxGraphemes === \"number\") {\n    if (graphemeLen(value) > def2.maxGraphemes) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be longer than ${def2.maxGraphemes} graphemes`\n        )\n      };\n    }\n  }\n  if (typeof def2.minGraphemes === \"number\") {\n    if (graphemeLen(value) < def2.minGraphemes) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be shorter than ${def2.minGraphemes} graphemes`\n        )\n      };\n    }\n  }\n  if (typeof def2.format === \"string\") {\n    switch (def2.format) {\n      case \"datetime\":\n        return datetime(path, value);\n      case \"uri\":\n        return uri(path, value);\n      case \"at-uri\":\n        return atUri(path, value);\n      case \"did\":\n        return did(path, value);\n      case \"handle\":\n        return handle(path, value);\n      case \"at-identifier\":\n        return atIdentifier(path, value);\n      case \"nsid\":\n        return nsid(path, value);\n      case \"cid\":\n        return cid(path, value);\n    }\n  }\n  return { success: true, value };\n}\nfunction bytes(lexicons2, path, def2, value) {\n  def2 = def2;\n  if (!value || !(value instanceof Uint8Array)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a byte array`)\n    };\n  }\n  if (typeof def2.maxLength === \"number\") {\n    if (value.byteLength > def2.maxLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be larger than ${def2.maxLength} bytes`\n        )\n      };\n    }\n  }\n  if (typeof def2.minLength === \"number\") {\n    if (value.byteLength < def2.minLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be smaller than ${def2.minLength} bytes`\n        )\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction cidLink(lexicons2, path, def2, value) {\n  if (CID.asCID(value) === null) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a CID`)\n    };\n  }\n  return { success: true, value };\n}\nfunction unknown(lexicons2, path, def2, value) {\n  if (!value || typeof value !== \"object\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an object`)\n    };\n  }\n  return { success: true, value };\n}\n\n// ../lexicon/src/blob-refs.ts\nvar typedJsonBlobRef = mod.object({\n  $type: mod.literal(\"blob\"),\n  ref: schema.cid,\n  mimeType: mod.string(),\n  size: mod.number()\n}).strict();\nvar untypedJsonBlobRef = mod.object({\n  cid: mod.string(),\n  mimeType: mod.string()\n}).strict();\nvar jsonBlobRef = mod.union([typedJsonBlobRef, untypedJsonBlobRef]);\nvar BlobRef = class {\n  constructor(ref, mimeType, size, original) {\n    this.ref = ref;\n    this.mimeType = mimeType;\n    this.size = size;\n    this.original = original ?? {\n      $type: \"blob\",\n      ref,\n      mimeType,\n      size\n    };\n  }\n  static asBlobRef(obj) {\n    if (check_exports.is(obj, jsonBlobRef)) {\n      return BlobRef.fromJsonRef(obj);\n    }\n    return null;\n  }\n  static fromJsonRef(json) {\n    if (check_exports.is(json, typedJsonBlobRef)) {\n      return new BlobRef(json.ref, json.mimeType, json.size);\n    } else {\n      return new BlobRef(CID.parse(json.cid), json.mimeType, -1, json);\n    }\n  }\n  ipld() {\n    return {\n      $type: \"blob\",\n      ref: this.ref,\n      mimeType: this.mimeType,\n      size: this.size\n    };\n  }\n  toJSON() {\n    return ipldToJson(this.ipld());\n  }\n};\n\n// ../lexicon/src/validators/blob.ts\nfunction blob(lexicons2, path, def2, value) {\n  if (!value || !(value instanceof BlobRef)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} should be a blob ref`)\n    };\n  }\n  return { success: true, value };\n}\n\n// ../lexicon/src/validators/complex.ts\nfunction validate2(lexicons2, path, def2, value) {\n  switch (def2.type) {\n    case \"boolean\":\n      return boolean(lexicons2, path, def2, value);\n    case \"integer\":\n      return integer(lexicons2, path, def2, value);\n    case \"string\":\n      return string2(lexicons2, path, def2, value);\n    case \"bytes\":\n      return bytes(lexicons2, path, def2, value);\n    case \"cid-link\":\n      return cidLink(lexicons2, path, def2, value);\n    case \"unknown\":\n      return unknown(lexicons2, path, def2, value);\n    case \"object\":\n      return object(lexicons2, path, def2, value);\n    case \"array\":\n      return array(lexicons2, path, def2, value);\n    case \"blob\":\n      return blob(lexicons2, path, def2, value);\n    default:\n      return {\n        success: false,\n        error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)\n      };\n  }\n}\nfunction array(lexicons2, path, def2, value) {\n  if (!Array.isArray(value)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an array`)\n    };\n  }\n  if (typeof def2.maxLength === \"number\") {\n    if (value.length > def2.maxLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not have more than ${def2.maxLength} elements`\n        )\n      };\n    }\n  }\n  if (typeof def2.minLength === \"number\") {\n    if (value.length < def2.minLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not have fewer than ${def2.minLength} elements`\n        )\n      };\n    }\n  }\n  const itemsDef = def2.items;\n  for (let i = 0; i < value.length; i++) {\n    const itemValue = value[i];\n    const itemPath = `${path}/${i}`;\n    const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);\n    if (!res.success) {\n      return res;\n    }\n  }\n  return { success: true, value };\n}\nfunction object(lexicons2, path, def2, value) {\n  def2 = def2;\n  if (!value || typeof value !== \"object\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an object`)\n    };\n  }\n  const requiredProps = new Set(def2.required);\n  const nullableProps = new Set(def2.nullable);\n  let resultValue = value;\n  if (typeof def2.properties === \"object\") {\n    for (const key in def2.properties) {\n      if (value[key] === null && nullableProps.has(key)) {\n        continue;\n      }\n      const propDef = def2.properties[key];\n      const propPath = `${path}/${key}`;\n      const validated = validateOneOf(lexicons2, propPath, propDef, value[key]);\n      const propValue = validated.success ? validated.value : value[key];\n      const propIsUndefined = typeof propValue === \"undefined\";\n      if (propIsUndefined && requiredProps.has(key)) {\n        return {\n          success: false,\n          error: new ValidationError(`${path} must have the property \"${key}\"`)\n        };\n      } else if (!propIsUndefined && !validated.success) {\n        return validated;\n      }\n      if (propValue !== value[key]) {\n        if (resultValue === value) {\n          resultValue = { ...value };\n        }\n        resultValue[key] = propValue;\n      }\n    }\n  }\n  return { success: true, value: resultValue };\n}\n\n// ../lexicon/src/util.ts\nfunction toLexUri(str, baseUri) {\n  if (str.startsWith(\"lex:\")) {\n    return str;\n  }\n  if (str.startsWith(\"#\")) {\n    if (!baseUri) {\n      throw new Error(`Unable to resolve uri without anchor: ${str}`);\n    }\n    return `${baseUri}${str}`;\n  }\n  return `lex:${str}`;\n}\nfunction validateOneOf(lexicons2, path, def2, value, mustBeObj = false) {\n  let error;\n  let concreteDefs;\n  if (def2.type === \"union\") {\n    if (!isDiscriminatedObject(value)) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must be an object which includes the \"$type\" property`\n        )\n      };\n    }\n    if (!def2.refs.includes(toLexUri(value.$type))) {\n      if (def2.closed) {\n        return {\n          success: false,\n          error: new ValidationError(\n            `${path} $type must be one of ${def2.refs.join(\", \")}`\n          )\n        };\n      }\n      return { success: true, value };\n    } else {\n      concreteDefs = toConcreteTypes(lexicons2, {\n        type: \"ref\",\n        ref: value.$type\n      });\n    }\n  } else {\n    concreteDefs = toConcreteTypes(lexicons2, def2);\n  }\n  for (const concreteDef of concreteDefs) {\n    const result = mustBeObj ? object(lexicons2, path, concreteDef, value) : validate2(lexicons2, path, concreteDef, value);\n    if (result.success) {\n      return result;\n    }\n    error ?? (error = result.error);\n  }\n  if (concreteDefs.length > 1) {\n    return {\n      success: false,\n      error: new ValidationError(\n        `${path} did not match any of the expected definitions`\n      )\n    };\n  }\n  return { success: false, error };\n}\nfunction assertValidOneOf(lexicons2, path, def2, value, mustBeObj = false) {\n  const res = validateOneOf(lexicons2, path, def2, value, mustBeObj);\n  if (!res.success)\n    throw res.error;\n  return res.value;\n}\nfunction toConcreteTypes(lexicons2, def2) {\n  if (def2.type === \"ref\") {\n    return [lexicons2.getDefOrThrow(def2.ref)];\n  } else if (def2.type === \"union\") {\n    return def2.refs.map((ref) => lexicons2.getDefOrThrow(ref)).flat();\n  } else {\n    return [def2];\n  }\n}\n\n// ../lexicon/src/validators/xrpc.ts\nfunction params(lexicons2, path, def2, val) {\n  const value = val && typeof val === \"object\" ? val : {};\n  const requiredProps = new Set(def2.required ?? []);\n  let resultValue = value;\n  if (typeof def2.properties === \"object\") {\n    for (const key in def2.properties) {\n      const propDef = def2.properties[key];\n      const validated = propDef.type === \"array\" ? array(lexicons2, key, propDef, value[key]) : validate(lexicons2, key, propDef, value[key]);\n      const propValue = validated.success ? validated.value : value[key];\n      const propIsUndefined = typeof propValue === \"undefined\";\n      if (propIsUndefined && requiredProps.has(key)) {\n        return {\n          success: false,\n          error: new ValidationError(`${path} must have the property \"${key}\"`)\n        };\n      } else if (!propIsUndefined && !validated.success) {\n        return validated;\n      }\n      if (propValue !== value[key]) {\n        if (resultValue === value) {\n          resultValue = { ...value };\n        }\n        resultValue[key] = propValue;\n      }\n    }\n  }\n  return { success: true, value: resultValue };\n}\n\n// ../lexicon/src/validation.ts\nfunction assertValidRecord(lexicons2, def2, value) {\n  const res = object(lexicons2, \"Record\", def2.record, value);\n  if (!res.success)\n    throw res.error;\n  return res.value;\n}\nfunction assertValidXrpcParams(lexicons2, def2, value) {\n  if (def2.parameters) {\n    const res = params(lexicons2, \"Params\", def2.parameters, value);\n    if (!res.success)\n      throw res.error;\n    return res.value;\n  }\n}\nfunction assertValidXrpcInput(lexicons2, def2, value) {\n  if (def2.input?.schema) {\n    return assertValidOneOf(lexicons2, \"Input\", def2.input.schema, value, true);\n  }\n}\nfunction assertValidXrpcOutput(lexicons2, def2, value) {\n  if (def2.output?.schema) {\n    return assertValidOneOf(lexicons2, \"Output\", def2.output.schema, value, true);\n  }\n}\nfunction assertValidXrpcMessage(lexicons2, def2, value) {\n  if (def2.message?.schema) {\n    return assertValidOneOf(\n      lexicons2,\n      \"Message\",\n      def2.message.schema,\n      value,\n      true\n    );\n  }\n}\n\n// ../lexicon/src/lexicons.ts\nvar Lexicons = class {\n  constructor(docs) {\n    this.docs = /* @__PURE__ */ new Map();\n    this.defs = /* @__PURE__ */ new Map();\n    if (docs?.length) {\n      for (const doc of docs) {\n        this.add(doc);\n      }\n    }\n  }\n  add(doc) {\n    try {\n      lexiconDoc.parse(doc);\n    } catch (e) {\n      if (e instanceof ZodError) {\n        throw new LexiconDocMalformedError(\n          `Failed to parse schema definition ${doc.id}`,\n          doc,\n          e.issues\n        );\n      } else {\n        throw e;\n      }\n    }\n    const validatedDoc = doc;\n    const uri2 = toLexUri(validatedDoc.id);\n    if (this.docs.has(uri2)) {\n      throw new Error(`${uri2} has already been registered`);\n    }\n    resolveRefUris(validatedDoc, uri2);\n    this.docs.set(uri2, validatedDoc);\n    for (const [defUri, def2] of iterDefs(validatedDoc)) {\n      this.defs.set(defUri, def2);\n    }\n  }\n  remove(uri2) {\n    uri2 = toLexUri(uri2);\n    const doc = this.docs.get(uri2);\n    if (!doc) {\n      throw new Error(`Unable to remove \"${uri2}\": does not exist`);\n    }\n    for (const [defUri, _def] of iterDefs(doc)) {\n      this.defs.delete(defUri);\n    }\n    this.docs.delete(uri2);\n  }\n  get(uri2) {\n    uri2 = toLexUri(uri2);\n    return this.docs.get(uri2);\n  }\n  getDef(uri2) {\n    uri2 = toLexUri(uri2);\n    return this.defs.get(uri2);\n  }\n  getDefOrThrow(uri2, types) {\n    const def2 = this.getDef(uri2);\n    if (!def2) {\n      throw new LexiconDefNotFoundError(`Lexicon not found: ${uri2}`);\n    }\n    if (types && !types.includes(def2.type)) {\n      throw new InvalidLexiconError(\n        `Not a ${types.join(\" or \")} lexicon: ${uri2}`\n      );\n    }\n    return def2;\n  }\n  validate(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"record\", \"object\"]);\n    if (!isObj(value)) {\n      throw new ValidationError(`Value must be an object`);\n    }\n    if (def2.type === \"record\") {\n      return object(this, \"Record\", def2.record, value);\n    } else if (def2.type === \"object\") {\n      return object(this, \"Object\", def2, value);\n    } else {\n      throw new InvalidLexiconError(\"Definition must be a record or object\");\n    }\n  }\n  assertValidRecord(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"record\"]);\n    if (!isObj(value)) {\n      throw new ValidationError(`Record must be an object`);\n    }\n    if (!hasProp(value, \"$type\") || typeof value.$type !== \"string\") {\n      throw new ValidationError(`Record/$type must be a string`);\n    }\n    const $type = value.$type || \"\";\n    if (toLexUri($type) !== lexUri) {\n      throw new ValidationError(\n        `Invalid $type: must be ${lexUri}, got ${$type}`\n      );\n    }\n    return assertValidRecord(this, def2, value);\n  }\n  assertValidXrpcParams(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\n      \"query\",\n      \"procedure\",\n      \"subscription\"\n    ]);\n    return assertValidXrpcParams(\n      this,\n      def2,\n      value\n    );\n  }\n  assertValidXrpcInput(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"procedure\"]);\n    return assertValidXrpcInput(this, def2, value);\n  }\n  assertValidXrpcOutput(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"query\", \"procedure\"]);\n    return assertValidXrpcOutput(\n      this,\n      def2,\n      value\n    );\n  }\n  assertValidXrpcMessage(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"subscription\"]);\n    return assertValidXrpcMessage(this, def2, value);\n  }\n  resolveLexUri(lexUri, ref) {\n    lexUri = toLexUri(lexUri);\n    return toLexUri(ref, lexUri);\n  }\n};\nfunction* iterDefs(doc) {\n  for (const defId in doc.defs) {\n    yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];\n    if (defId === \"main\") {\n      yield [`lex:${doc.id}`, doc.defs[defId]];\n    }\n  }\n}\nfunction resolveRefUris(obj, baseUri) {\n  for (const k in obj) {\n    if (obj.type === \"ref\") {\n      obj.ref = toLexUri(obj.ref, baseUri);\n    } else if (obj.type === \"union\") {\n      obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri));\n    } else if (Array.isArray(obj[k])) {\n      obj[k] = obj[k].map((item) => {\n        if (typeof item === \"string\") {\n          return item.startsWith(\"#\") ? toLexUri(item, baseUri) : item;\n        } else if (item && typeof item === \"object\") {\n          return resolveRefUris(item, baseUri);\n        }\n        return item;\n      });\n    } else if (obj[k] && typeof obj[k] === \"object\") {\n      obj[k] = resolveRefUris(obj[k], baseUri);\n    }\n  }\n  return obj;\n}\n\n// ../lexicon/src/serialize.ts\nvar lexToIpld = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => lexToIpld(item));\n  }\n  if (val && typeof val === \"object\") {\n    if (val instanceof BlobRef) {\n      return val.original;\n    }\n    if (CID.asCID(val) || val instanceof Uint8Array) {\n      return val;\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = lexToIpld(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\nvar ipldToLex = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => ipldToLex(item));\n  }\n  if (val && typeof val === \"object\") {\n    if ((val[\"$type\"] === \"blob\" || typeof val[\"cid\"] === \"string\" && typeof val[\"mimeType\"] === \"string\") && check_exports.is(val, jsonBlobRef)) {\n      return BlobRef.fromJsonRef(val);\n    }\n    if (CID.asCID(val) || val instanceof Uint8Array) {\n      return val;\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = ipldToLex(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\nvar lexToJson = (val) => {\n  return ipldToJson(lexToIpld(val));\n};\nvar stringifyLex = (val) => {\n  return JSON.stringify(lexToJson(val));\n};\nvar jsonToLex = (val) => {\n  return ipldToLex(jsonToIpld(val));\n};\nvar jsonStringToLex = (val) => {\n  return jsonToLex(JSON.parse(val));\n};\n\n// ../xrpc/src/types.ts\nvar errorResponseBody = mod.object({\n  error: mod.string().optional(),\n  message: mod.string().optional()\n});\nvar ResponseType = /* @__PURE__ */ ((ResponseType2) => {\n  ResponseType2[ResponseType2[\"Unknown\"] = 1] = \"Unknown\";\n  ResponseType2[ResponseType2[\"InvalidResponse\"] = 2] = \"InvalidResponse\";\n  ResponseType2[ResponseType2[\"Success\"] = 200] = \"Success\";\n  ResponseType2[ResponseType2[\"InvalidRequest\"] = 400] = \"InvalidRequest\";\n  ResponseType2[ResponseType2[\"AuthRequired\"] = 401] = \"AuthRequired\";\n  ResponseType2[ResponseType2[\"Forbidden\"] = 403] = \"Forbidden\";\n  ResponseType2[ResponseType2[\"XRPCNotSupported\"] = 404] = \"XRPCNotSupported\";\n  ResponseType2[ResponseType2[\"PayloadTooLarge\"] = 413] = \"PayloadTooLarge\";\n  ResponseType2[ResponseType2[\"RateLimitExceeded\"] = 429] = \"RateLimitExceeded\";\n  ResponseType2[ResponseType2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  ResponseType2[ResponseType2[\"MethodNotImplemented\"] = 501] = \"MethodNotImplemented\";\n  ResponseType2[ResponseType2[\"UpstreamFailure\"] = 502] = \"UpstreamFailure\";\n  ResponseType2[ResponseType2[\"NotEnoughResouces\"] = 503] = \"NotEnoughResouces\";\n  ResponseType2[ResponseType2[\"UpstreamTimeout\"] = 504] = \"UpstreamTimeout\";\n  return ResponseType2;\n})(ResponseType || {});\nvar ResponseTypeNames = {\n  [2 /* InvalidResponse */]: \"InvalidResponse\",\n  [200 /* Success */]: \"Success\",\n  [400 /* InvalidRequest */]: \"InvalidRequest\",\n  [401 /* AuthRequired */]: \"AuthenticationRequired\",\n  [403 /* Forbidden */]: \"Forbidden\",\n  [404 /* XRPCNotSupported */]: \"XRPCNotSupported\",\n  [413 /* PayloadTooLarge */]: \"PayloadTooLarge\",\n  [429 /* RateLimitExceeded */]: \"RateLimitExceeded\",\n  [500 /* InternalServerError */]: \"InternalServerError\",\n  [501 /* MethodNotImplemented */]: \"MethodNotImplemented\",\n  [502 /* UpstreamFailure */]: \"UpstreamFailure\",\n  [503 /* NotEnoughResouces */]: \"NotEnoughResouces\",\n  [504 /* UpstreamTimeout */]: \"UpstreamTimeout\"\n};\nvar ResponseTypeStrings = {\n  [2 /* InvalidResponse */]: \"Invalid Response\",\n  [200 /* Success */]: \"Success\",\n  [400 /* InvalidRequest */]: \"Invalid Request\",\n  [401 /* AuthRequired */]: \"Authentication Required\",\n  [403 /* Forbidden */]: \"Forbidden\",\n  [404 /* XRPCNotSupported */]: \"XRPC Not Supported\",\n  [413 /* PayloadTooLarge */]: \"Payload Too Large\",\n  [429 /* RateLimitExceeded */]: \"Rate Limit Exceeded\",\n  [500 /* InternalServerError */]: \"Internal Server Error\",\n  [501 /* MethodNotImplemented */]: \"Method Not Implemented\",\n  [502 /* UpstreamFailure */]: \"Upstream Failure\",\n  [503 /* NotEnoughResouces */]: \"Not Enough Resouces\",\n  [504 /* UpstreamTimeout */]: \"Upstream Timeout\"\n};\nvar XRPCResponse = class {\n  constructor(data, headers) {\n    this.data = data;\n    this.headers = headers;\n    this.success = true;\n  }\n};\nvar XRPCError = class extends Error {\n  constructor(status, error, message) {\n    super(message || error || ResponseTypeStrings[status]);\n    this.status = status;\n    this.error = error;\n    this.success = false;\n    if (!this.error) {\n      this.error = ResponseTypeNames[status];\n    }\n  }\n};\nvar XRPCInvalidResponseError = class extends XRPCError {\n  constructor(lexiconNsid, validationError, responseBody) {\n    super(\n      2 /* InvalidResponse */,\n      ResponseTypeStrings[2 /* InvalidResponse */],\n      `The server gave an invalid response and may be out of date.`\n    );\n    this.lexiconNsid = lexiconNsid;\n    this.validationError = validationError;\n    this.responseBody = responseBody;\n  }\n};\n\n// ../xrpc/src/util.ts\nfunction getMethodSchemaHTTPMethod(schema2) {\n  if (schema2.type === \"procedure\") {\n    return \"post\";\n  }\n  return \"get\";\n}\nfunction constructMethodCallUri(nsid2, schema2, serviceUri, params2) {\n  const uri2 = new URL(serviceUri);\n  uri2.pathname = `/xrpc/${nsid2}`;\n  if (params2) {\n    for (const [key, value] of Object.entries(params2)) {\n      const paramSchema = schema2.parameters?.properties?.[key];\n      if (!paramSchema) {\n        throw new Error(`Invalid query parameter: ${key}`);\n      }\n      if (value !== void 0) {\n        if (paramSchema.type === \"array\") {\n          const vals = [];\n          vals.concat(value).forEach((val) => {\n            uri2.searchParams.append(\n              key,\n              encodeQueryParam(paramSchema.items.type, val)\n            );\n          });\n        } else {\n          uri2.searchParams.set(key, encodeQueryParam(paramSchema.type, value));\n        }\n      }\n    }\n  }\n  return uri2.toString();\n}\nfunction encodeQueryParam(type, value) {\n  if (type === \"string\" || type === \"unknown\") {\n    return String(value);\n  }\n  if (type === \"float\") {\n    return String(Number(value));\n  } else if (type === \"integer\") {\n    return String(Number(value) | 0);\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"datetime\") {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    return String(value);\n  }\n  throw new Error(`Unsupported query param type: ${type}`);\n}\nfunction constructMethodCallHeaders(schema2, data, opts) {\n  const headers = opts?.headers || {};\n  if (schema2.type === \"procedure\") {\n    if (opts?.encoding) {\n      headers[\"Content-Type\"] = opts.encoding;\n    }\n    if (data && typeof data === \"object\") {\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"application/json\";\n      }\n    }\n  }\n  return headers;\n}\nfunction encodeMethodCallBody(headers, data) {\n  if (!headers[\"Content-Type\"] || typeof data === \"undefined\") {\n    return void 0;\n  }\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n  if (headers[\"Content-Type\"].startsWith(\"text/\")) {\n    return new TextEncoder().encode(data.toString());\n  }\n  if (headers[\"Content-Type\"].startsWith(\"application/json\")) {\n    return new TextEncoder().encode(stringifyLex(data));\n  }\n  return data;\n}\nfunction httpResponseCodeToEnum(status) {\n  let resCode;\n  if (status in ResponseType) {\n    resCode = status;\n  } else if (status >= 100 && status < 200) {\n    resCode = 404 /* XRPCNotSupported */;\n  } else if (status >= 200 && status < 300) {\n    resCode = 200 /* Success */;\n  } else if (status >= 300 && status < 400) {\n    resCode = 404 /* XRPCNotSupported */;\n  } else if (status >= 400 && status < 500) {\n    resCode = 400 /* InvalidRequest */;\n  } else {\n    resCode = 500 /* InternalServerError */;\n  }\n  return resCode;\n}\nfunction httpResponseBodyParse(mimeType, data) {\n  if (mimeType) {\n    if (mimeType.includes(\"application/json\") && data?.byteLength) {\n      try {\n        const str = new TextDecoder().decode(data);\n        return jsonStringToLex(str);\n      } catch (e) {\n        throw new XRPCError(\n          2 /* InvalidResponse */,\n          `Failed to parse response body: ${String(e)}`\n        );\n      }\n    }\n    if (mimeType.startsWith(\"text/\") && data?.byteLength) {\n      try {\n        return new TextDecoder().decode(data);\n      } catch (e) {\n        throw new XRPCError(\n          2 /* InvalidResponse */,\n          `Failed to parse response body: ${String(e)}`\n        );\n      }\n    }\n  }\n  if (data instanceof ArrayBuffer) {\n    return new Uint8Array(data);\n  }\n  return data;\n}\n\n// ../xrpc/src/client.ts\nvar Client = class {\n  constructor() {\n    this.fetch = defaultFetchHandler;\n    this.lex = new Lexicons();\n  }\n  async call(serviceUri, methodNsid, params2, data, opts) {\n    return this.service(serviceUri).call(methodNsid, params2, data, opts);\n  }\n  service(serviceUri) {\n    return new ServiceClient(this, serviceUri);\n  }\n  addLexicon(doc) {\n    this.lex.add(doc);\n  }\n  addLexicons(docs) {\n    for (const doc of docs) {\n      this.addLexicon(doc);\n    }\n  }\n  removeLexicon(uri2) {\n    this.lex.remove(uri2);\n  }\n};\nvar ServiceClient = class {\n  constructor(baseClient, serviceUri) {\n    this.headers = {};\n    this.baseClient = baseClient;\n    this.uri = typeof serviceUri === \"string\" ? new URL(serviceUri) : serviceUri;\n  }\n  setHeader(key, value) {\n    this.headers[key] = value;\n  }\n  unsetHeader(key) {\n    delete this.headers[key];\n  }\n  async call(methodNsid, params2, data, opts) {\n    const def2 = this.baseClient.lex.getDefOrThrow(methodNsid);\n    if (!def2 || def2.type !== \"query\" && def2.type !== \"procedure\") {\n      throw new Error(\n        `Invalid lexicon: ${methodNsid}. Must be a query or procedure.`\n      );\n    }\n    const httpMethod = getMethodSchemaHTTPMethod(def2);\n    const httpUri = constructMethodCallUri(methodNsid, def2, this.uri, params2);\n    const httpHeaders = constructMethodCallHeaders(def2, data, {\n      headers: {\n        ...this.headers,\n        ...opts?.headers\n      },\n      encoding: opts?.encoding\n    });\n    const res = await this.baseClient.fetch(\n      httpUri,\n      httpMethod,\n      httpHeaders,\n      data\n    );\n    const resCode = httpResponseCodeToEnum(res.status);\n    if (resCode === 200 /* Success */) {\n      try {\n        this.baseClient.lex.assertValidXrpcOutput(methodNsid, res.body);\n      } catch (e) {\n        if (e instanceof ValidationError) {\n          throw new XRPCInvalidResponseError(methodNsid, e, res.body);\n        } else {\n          throw e;\n        }\n      }\n      return new XRPCResponse(res.body, res.headers);\n    } else {\n      if (res.body && isErrorResponseBody(res.body)) {\n        throw new XRPCError(resCode, res.body.error, res.body.message);\n      } else {\n        throw new XRPCError(resCode);\n      }\n    }\n  }\n};\nasync function defaultFetchHandler(httpUri, httpMethod, httpHeaders, httpReqBody) {\n  try {\n    const reqInit = {\n      method: httpMethod,\n      headers: httpHeaders,\n      body: encodeMethodCallBody(httpHeaders, httpReqBody),\n      duplex: \"half\"\n    };\n    const res = await fetch(httpUri, reqInit);\n    const resBody = await res.arrayBuffer();\n    return {\n      status: res.status,\n      headers: Object.fromEntries(res.headers.entries()),\n      body: httpResponseBodyParse(res.headers.get(\"content-type\"), resBody)\n    };\n  } catch (e) {\n    throw new XRPCError(1 /* Unknown */, String(e));\n  }\n}\nfunction isErrorResponseBody(v) {\n  return errorResponseBody.safeParse(v).success;\n}\n\n// ../xrpc/src/index.ts\nvar defaultInst = new Client();\n\n// src/client/lexicons.ts\nvar schemaDict = {\n  ComAtprotoAdminDefs: {\n    lexicon: 1,\n    id: \"com.atproto.admin.defs\",\n    defs: {\n      actionView: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"action\",\n          \"subject\",\n          \"subjectBlobCids\",\n          \"reason\",\n          \"createdBy\",\n          \"createdAt\",\n          \"resolvedReportIds\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          action: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionType\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoRef\",\n              \"lex:com.atproto.repo.strongRef\"\n            ]\n          },\n          subjectBlobCids: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          createLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          negateLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          reason: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          reversal: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionReversal\"\n          },\n          resolvedReportIds: {\n            type: \"array\",\n            items: {\n              type: \"integer\"\n            }\n          }\n        }\n      },\n      actionViewDetail: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"action\",\n          \"subject\",\n          \"subjectBlobs\",\n          \"reason\",\n          \"createdBy\",\n          \"createdAt\",\n          \"resolvedReports\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          action: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionType\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoView\",\n              \"lex:com.atproto.admin.defs#recordView\"\n            ]\n          },\n          subjectBlobs: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#blobView\"\n            }\n          },\n          createLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          negateLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          reason: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          reversal: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionReversal\"\n          },\n          resolvedReports: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#reportView\"\n            }\n          }\n        }\n      },\n      actionViewCurrent: {\n        type: \"object\",\n        required: [\"id\", \"action\"],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          action: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionType\"\n          }\n        }\n      },\n      actionReversal: {\n        type: \"object\",\n        required: [\"reason\", \"createdBy\", \"createdAt\"],\n        properties: {\n          reason: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      actionType: {\n        type: \"string\",\n        knownValues: [\n          \"lex:com.atproto.admin.defs#takedown\",\n          \"lex:com.atproto.admin.defs#flag\",\n          \"lex:com.atproto.admin.defs#acknowledge\"\n        ]\n      },\n      takedown: {\n        type: \"token\",\n        description: \"Moderation action type: Takedown. Indicates that content should not be served by the PDS.\"\n      },\n      flag: {\n        type: \"token\",\n        description: \"Moderation action type: Flag. Indicates that the content was reviewed and considered to violate PDS rules, but may still be served.\"\n      },\n      acknowledge: {\n        type: \"token\",\n        description: \"Moderation action type: Acknowledge. Indicates that the content was reviewed and not considered to violate PDS rules.\"\n      },\n      reportView: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"reasonType\",\n          \"subject\",\n          \"reportedBy\",\n          \"createdAt\",\n          \"resolvedByActionIds\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          reasonType: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.moderation.defs#reasonType\"\n          },\n          reason: {\n            type: \"string\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoRef\",\n              \"lex:com.atproto.repo.strongRef\"\n            ]\n          },\n          reportedBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          resolvedByActionIds: {\n            type: \"array\",\n            items: {\n              type: \"integer\"\n            }\n          }\n        }\n      },\n      reportViewDetail: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"reasonType\",\n          \"subject\",\n          \"reportedBy\",\n          \"createdAt\",\n          \"resolvedByActions\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          reasonType: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.moderation.defs#reasonType\"\n          },\n          reason: {\n            type: \"string\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoView\",\n              \"lex:com.atproto.admin.defs#recordView\"\n            ]\n          },\n          reportedBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          resolvedByActions: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#actionView\"\n            }\n          }\n        }\n      },\n      repoView: {\n        type: \"object\",\n        required: [\n          \"did\",\n          \"handle\",\n          \"relatedRecords\",\n          \"indexedAt\",\n          \"moderation\"\n        ],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          email: {\n            type: \"string\"\n          },\n          relatedRecords: {\n            type: \"array\",\n            items: {\n              type: \"unknown\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderation\"\n          },\n          invitedBy: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.server.defs#inviteCode\"\n          }\n        }\n      },\n      repoViewDetail: {\n        type: \"object\",\n        required: [\n          \"did\",\n          \"handle\",\n          \"relatedRecords\",\n          \"indexedAt\",\n          \"moderation\"\n        ],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          email: {\n            type: \"string\"\n          },\n          relatedRecords: {\n            type: \"array\",\n            items: {\n              type: \"unknown\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderationDetail\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          },\n          invitedBy: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.server.defs#inviteCode\"\n          },\n          invites: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.server.defs#inviteCode\"\n            }\n          }\n        }\n      },\n      repoRef: {\n        type: \"object\",\n        required: [\"did\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          }\n        }\n      },\n      recordView: {\n        type: \"object\",\n        required: [\n          \"uri\",\n          \"cid\",\n          \"value\",\n          \"blobCids\",\n          \"indexedAt\",\n          \"moderation\",\n          \"repo\"\n        ],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          value: {\n            type: \"unknown\"\n          },\n          blobCids: {\n            type: \"array\",\n            items: {\n              type: \"string\",\n              format: \"cid\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderation\"\n          },\n          repo: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#repoView\"\n          }\n        }\n      },\n      recordViewDetail: {\n        type: \"object\",\n        required: [\n          \"uri\",\n          \"cid\",\n          \"value\",\n          \"blobs\",\n          \"indexedAt\",\n          \"moderation\",\n          \"repo\"\n        ],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          value: {\n            type: \"unknown\"\n          },\n          blobs: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#blobView\"\n            }\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderationDetail\"\n          },\n          repo: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#repoView\"\n          }\n        }\n      },\n      moderation: {\n        type: \"object\",\n        required: [],\n        properties: {\n          currentAction: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionViewCurrent\"\n          }\n        }\n      },\n      moderationDetail: {\n        type: \"object\",\n        required: [\"actions\", \"reports\"],\n        properties: {\n          currentAction: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionViewCurrent\"\n          },\n          actions: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#actionView\"\n            }\n          },\n          reports: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#reportView\"\n            }\n          }\n        }\n      },\n      blobView: {\n        type: \"object\",\n        required: [\"cid\", \"mimeType\", \"size\", \"createdAt\"],\n        properties: {\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          mimeType: {\n            type: \"string\"\n          },\n          size: {\n            type: \"integer\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          details: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#imageDetails\",\n              \"lex:com.atproto.admin.defs#videoDetails\"\n            ]\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderation\"\n          }\n        }\n      },\n      imageDetails: {\n        type: \"object\",\n        required: [\"width\", \"height\"],\n        properties: {\n          width: {\n            type: \"integer\"\n          },\n          height: {\n            type: \"integer\"\n          }\n        }\n      },\n      videoDetails: {\n        type: \"object\",\n        required: [\"width\", \"height\", \"length\"],\n        properties: {\n          width: {\n            type: \"integer\"\n          },\n          height: {\n            type: \"integer\"\n          },\n          length: {\n            type: \"integer\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminDisableInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.admin.disableInviteCodes\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Disable some set of codes and/or all codes associated with a set of users\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            properties: {\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              accounts: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getInviteCodes\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Admin view of invite codes\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            sort: {\n              type: \"string\",\n              knownValues: [\"recent\", \"usage\"],\n              default: \"recent\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 500,\n              default: 100\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codes\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.server.defs#inviteCode\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationAction: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationAction\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a moderation action.\",\n        parameters: {\n          type: \"params\",\n          required: [\"id\"],\n          properties: {\n            id: {\n              type: \"integer\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationActions: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationActions\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List moderation actions related to a subject.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            subject: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actions\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              actions: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.admin.defs#actionView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationReport: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationReport\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a moderation report.\",\n        parameters: {\n          type: \"params\",\n          required: [\"id\"],\n          properties: {\n            id: {\n              type: \"integer\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#reportViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationReports: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationReports\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List moderation reports related to a subject.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            subject: {\n              type: \"string\"\n            },\n            resolved: {\n              type: \"boolean\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"reports\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              reports: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.admin.defs#reportView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetRecord: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getRecord\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a record.\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#recordViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetRepo: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getRepo\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a repository.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#repoViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminResolveModerationReports: {\n    lexicon: 1,\n    id: \"com.atproto.admin.resolveModerationReports\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Resolve moderation reports by an action.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actionId\", \"reportIds\", \"createdBy\"],\n            properties: {\n              actionId: {\n                type: \"integer\"\n              },\n              reportIds: {\n                type: \"array\",\n                items: {\n                  type: \"integer\"\n                }\n              },\n              createdBy: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionView\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminReverseModerationAction: {\n    lexicon: 1,\n    id: \"com.atproto.admin.reverseModerationAction\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Reverse a moderation action.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"id\", \"reason\", \"createdBy\"],\n            properties: {\n              id: {\n                type: \"integer\"\n              },\n              reason: {\n                type: \"string\"\n              },\n              createdBy: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionView\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminSearchRepos: {\n    lexicon: 1,\n    id: \"com.atproto.admin.searchRepos\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find repositories based on a search term.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            term: {\n              type: \"string\"\n            },\n            invitedBy: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repos\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              repos: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.admin.defs#repoView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminTakeModerationAction: {\n    lexicon: 1,\n    id: \"com.atproto.admin.takeModerationAction\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Take a moderation action on a repo.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"action\", \"subject\", \"reason\", \"createdBy\"],\n            properties: {\n              action: {\n                type: \"string\",\n                knownValues: [\n                  \"com.atproto.admin.defs#takedown\",\n                  \"com.atproto.admin.defs#flag\",\n                  \"com.atproto.admin.defs#acknowledge\"\n                ]\n              },\n              subject: {\n                type: \"union\",\n                refs: [\n                  \"lex:com.atproto.admin.defs#repoRef\",\n                  \"lex:com.atproto.repo.strongRef\"\n                ]\n              },\n              subjectBlobCids: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"cid\"\n                }\n              },\n              createLabelVals: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              negateLabelVals: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              reason: {\n                type: \"string\"\n              },\n              createdBy: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionView\"\n          }\n        },\n        errors: [\n          {\n            name: \"SubjectHasAction\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoAdminUpdateAccountEmail: {\n    lexicon: 1,\n    id: \"com.atproto.admin.updateAccountEmail\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Administrative action to update an account's email\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"account\", \"email\"],\n            properties: {\n              account: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminUpdateAccountHandle: {\n    lexicon: 1,\n    id: \"com.atproto.admin.updateAccountHandle\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Administrative action to update an account's handle\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"did\", \"handle\"],\n            properties: {\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoIdentityResolveHandle: {\n    lexicon: 1,\n    id: \"com.atproto.identity.resolveHandle\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Provides the DID of a repo.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            handle: {\n              type: \"string\",\n              format: \"handle\",\n              description: \"The handle to resolve. If not supplied, will resolve the host's own handle.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"did\"],\n            properties: {\n              did: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoIdentityUpdateHandle: {\n    lexicon: 1,\n    id: \"com.atproto.identity.updateHandle\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Updates the handle of the account\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"handle\"],\n            properties: {\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoLabelDefs: {\n    lexicon: 1,\n    id: \"com.atproto.label.defs\",\n    defs: {\n      label: {\n        type: \"object\",\n        description: \"Metadata tag on an atproto resource (eg, repo or record)\",\n        required: [\"src\", \"uri\", \"val\", \"cts\"],\n        properties: {\n          src: {\n            type: \"string\",\n            format: \"did\",\n            description: \"DID of the actor who created this label\"\n          },\n          uri: {\n            type: \"string\",\n            format: \"uri\",\n            description: \"AT URI of the record, repository (account), or other resource which this label applies to\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\",\n            description: \"optionally, CID specifying the specific version of 'uri' resource this label applies to\"\n          },\n          val: {\n            type: \"string\",\n            maxLength: 128,\n            description: \"the short string name of the value or type of this label\"\n          },\n          neg: {\n            type: \"boolean\",\n            description: \"if true, this is a negation label, overwriting a previous label\"\n          },\n          cts: {\n            type: \"string\",\n            format: \"datetime\",\n            description: \"timestamp when this label was created\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoLabelQueryLabels: {\n    lexicon: 1,\n    id: \"com.atproto.label.queryLabels\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find labels relevant to the provided URI patterns.\",\n        parameters: {\n          type: \"params\",\n          required: [\"uriPatterns\"],\n          properties: {\n            uriPatterns: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              },\n              description: \"List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI\"\n            },\n            sources: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"did\"\n              },\n              description: \"Optional list of label sources (DIDs) to filter on\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 250,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"labels\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              labels: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.label.defs#label\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoLabelSubscribeLabels: {\n    lexicon: 1,\n    id: \"com.atproto.label.subscribeLabels\",\n    defs: {\n      main: {\n        type: \"subscription\",\n        description: \"Subscribe to label updates\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            cursor: {\n              type: \"integer\",\n              description: \"The last known event to backfill from.\"\n            }\n          }\n        },\n        message: {\n          schema: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.label.subscribeLabels#labels\",\n              \"lex:com.atproto.label.subscribeLabels#info\"\n            ]\n          }\n        },\n        errors: [\n          {\n            name: \"FutureCursor\"\n          }\n        ]\n      },\n      labels: {\n        type: \"object\",\n        required: [\"seq\", \"labels\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      info: {\n        type: \"object\",\n        required: [\"name\"],\n        properties: {\n          name: {\n            type: \"string\",\n            knownValues: [\"OutdatedCursor\"]\n          },\n          message: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoModerationCreateReport: {\n    lexicon: 1,\n    id: \"com.atproto.moderation.createReport\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Report a repo or a record.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"reasonType\", \"subject\"],\n            properties: {\n              reasonType: {\n                type: \"ref\",\n                ref: \"lex:com.atproto.moderation.defs#reasonType\"\n              },\n              reason: {\n                type: \"string\"\n              },\n              subject: {\n                type: \"union\",\n                refs: [\n                  \"lex:com.atproto.admin.defs#repoRef\",\n                  \"lex:com.atproto.repo.strongRef\"\n                ]\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\n              \"id\",\n              \"reasonType\",\n              \"subject\",\n              \"reportedBy\",\n              \"createdAt\"\n            ],\n            properties: {\n              id: {\n                type: \"integer\"\n              },\n              reasonType: {\n                type: \"ref\",\n                ref: \"lex:com.atproto.moderation.defs#reasonType\"\n              },\n              reason: {\n                type: \"string\"\n              },\n              subject: {\n                type: \"union\",\n                refs: [\n                  \"lex:com.atproto.admin.defs#repoRef\",\n                  \"lex:com.atproto.repo.strongRef\"\n                ]\n              },\n              reportedBy: {\n                type: \"string\",\n                format: \"did\"\n              },\n              createdAt: {\n                type: \"string\",\n                format: \"datetime\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoModerationDefs: {\n    lexicon: 1,\n    id: \"com.atproto.moderation.defs\",\n    defs: {\n      reasonType: {\n        type: \"string\",\n        knownValues: [\n          \"com.atproto.moderation.defs#reasonSpam\",\n          \"com.atproto.moderation.defs#reasonViolation\",\n          \"com.atproto.moderation.defs#reasonMisleading\",\n          \"com.atproto.moderation.defs#reasonSexual\",\n          \"com.atproto.moderation.defs#reasonRude\",\n          \"com.atproto.moderation.defs#reasonOther\"\n        ]\n      },\n      reasonSpam: {\n        type: \"token\",\n        description: \"Spam: frequent unwanted promotion, replies, mentions\"\n      },\n      reasonViolation: {\n        type: \"token\",\n        description: \"Direct violation of server rules, laws, terms of service\"\n      },\n      reasonMisleading: {\n        type: \"token\",\n        description: \"Misleading identity, affiliation, or content\"\n      },\n      reasonSexual: {\n        type: \"token\",\n        description: \"Unwanted or mis-labeled sexual content\"\n      },\n      reasonRude: {\n        type: \"token\",\n        description: \"Rude, harassing, explicit, or otherwise unwelcoming behavior\"\n      },\n      reasonOther: {\n        type: \"token\",\n        description: \"Other: reports not falling under another report category\"\n      }\n    }\n  },\n  ComAtprotoRepoApplyWrites: {\n    lexicon: 1,\n    id: \"com.atproto.repo.applyWrites\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Apply a batch transaction of creates, updates, and deletes.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"writes\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              validate: {\n                type: \"boolean\",\n                default: true,\n                description: \"Validate the records?\"\n              },\n              writes: {\n                type: \"array\",\n                items: {\n                  type: \"union\",\n                  refs: [\n                    \"lex:com.atproto.repo.applyWrites#create\",\n                    \"lex:com.atproto.repo.applyWrites#update\",\n                    \"lex:com.atproto.repo.applyWrites#delete\"\n                  ],\n                  closed: true\n                }\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      },\n      create: {\n        type: \"object\",\n        description: \"Create a new record.\",\n        required: [\"action\", \"collection\", \"value\"],\n        properties: {\n          collection: {\n            type: \"string\",\n            format: \"nsid\"\n          },\n          rkey: {\n            type: \"string\"\n          },\n          value: {\n            type: \"unknown\"\n          }\n        }\n      },\n      update: {\n        type: \"object\",\n        description: \"Update an existing record.\",\n        required: [\"action\", \"collection\", \"rkey\", \"value\"],\n        properties: {\n          collection: {\n            type: \"string\",\n            format: \"nsid\"\n          },\n          rkey: {\n            type: \"string\"\n          },\n          value: {\n            type: \"unknown\"\n          }\n        }\n      },\n      delete: {\n        type: \"object\",\n        description: \"Delete an existing record.\",\n        required: [\"action\", \"collection\", \"rkey\"],\n        properties: {\n          collection: {\n            type: \"string\",\n            format: \"nsid\"\n          },\n          rkey: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoCreateRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.createRecord\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create a new record.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"collection\", \"record\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              collection: {\n                type: \"string\",\n                format: \"nsid\",\n                description: \"The NSID of the record collection.\"\n              },\n              rkey: {\n                type: \"string\",\n                description: \"The key of the record.\"\n              },\n              validate: {\n                type: \"boolean\",\n                default: true,\n                description: \"Validate the record?\"\n              },\n              record: {\n                type: \"unknown\",\n                description: \"The record to create.\"\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous commit by cid.\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"cid\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoRepoDeleteRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.deleteRecord\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Delete a record, or ensure it doesn't exist.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"collection\", \"rkey\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              collection: {\n                type: \"string\",\n                format: \"nsid\",\n                description: \"The NSID of the record collection.\"\n              },\n              rkey: {\n                type: \"string\",\n                description: \"The key of the record.\"\n              },\n              swapRecord: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous record by cid.\"\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous commit by cid.\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoRepoDescribeRepo: {\n    lexicon: 1,\n    id: \"com.atproto.repo.describeRepo\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get information about the repo, including the list of collections.\",\n        parameters: {\n          type: \"params\",\n          required: [\"repo\"],\n          properties: {\n            repo: {\n              type: \"string\",\n              format: \"at-identifier\",\n              description: \"The handle or DID of the repo.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\n              \"handle\",\n              \"did\",\n              \"didDoc\",\n              \"collections\",\n              \"handleIsCorrect\"\n            ],\n            properties: {\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              didDoc: {\n                type: \"unknown\"\n              },\n              collections: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"nsid\"\n                }\n              },\n              handleIsCorrect: {\n                type: \"boolean\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoGetRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.getRecord\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a record.\",\n        parameters: {\n          type: \"params\",\n          required: [\"repo\", \"collection\", \"rkey\"],\n          properties: {\n            repo: {\n              type: \"string\",\n              format: \"at-identifier\",\n              description: \"The handle or DID of the repo.\"\n            },\n            collection: {\n              type: \"string\",\n              format: \"nsid\",\n              description: \"The NSID of the record collection.\"\n            },\n            rkey: {\n              type: \"string\",\n              description: \"The key of the record.\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The CID of the version of the record. If not specified, then return the most recent version.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"value\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              },\n              value: {\n                type: \"unknown\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoListRecords: {\n    lexicon: 1,\n    id: \"com.atproto.repo.listRecords\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List a range of records in a collection.\",\n        parameters: {\n          type: \"params\",\n          required: [\"repo\", \"collection\"],\n          properties: {\n            repo: {\n              type: \"string\",\n              format: \"at-identifier\",\n              description: \"The handle or DID of the repo.\"\n            },\n            collection: {\n              type: \"string\",\n              format: \"nsid\",\n              description: \"The NSID of the record type.\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50,\n              description: \"The number of records to return.\"\n            },\n            cursor: {\n              type: \"string\"\n            },\n            rkeyStart: {\n              type: \"string\",\n              description: \"DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)\"\n            },\n            rkeyEnd: {\n              type: \"string\",\n              description: \"DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)\"\n            },\n            reverse: {\n              type: \"boolean\",\n              description: \"Reverse the order of the returned records?\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"records\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              records: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.repo.listRecords#record\"\n                }\n              }\n            }\n          }\n        }\n      },\n      record: {\n        type: \"object\",\n        required: [\"uri\", \"cid\", \"value\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          value: {\n            type: \"unknown\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoPutRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.putRecord\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Write a record, creating or updating it as needed.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"collection\", \"rkey\", \"record\"],\n            nullable: [\"swapRecord\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              collection: {\n                type: \"string\",\n                format: \"nsid\",\n                description: \"The NSID of the record collection.\"\n              },\n              rkey: {\n                type: \"string\",\n                description: \"The key of the record.\"\n              },\n              validate: {\n                type: \"boolean\",\n                default: true,\n                description: \"Validate the record?\"\n              },\n              record: {\n                type: \"unknown\",\n                description: \"The record to write.\"\n              },\n              swapRecord: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous record by cid.\"\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous commit by cid.\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"cid\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoRepoStrongRef: {\n    lexicon: 1,\n    id: \"com.atproto.repo.strongRef\",\n    description: \"A URI with a content-hash fingerprint.\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"uri\", \"cid\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoUploadBlob: {\n    lexicon: 1,\n    id: \"com.atproto.repo.uploadBlob\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Upload a new blob to be added to repo in a later request.\",\n        input: {\n          encoding: \"*/*\"\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"blob\"],\n            properties: {\n              blob: {\n                type: \"blob\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateAccount: {\n    lexicon: 1,\n    id: \"com.atproto.server.createAccount\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an account.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"handle\", \"email\", \"password\"],\n            properties: {\n              email: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              inviteCode: {\n                type: \"string\"\n              },\n              password: {\n                type: \"string\"\n              },\n              recoveryKey: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"accessJwt\", \"refreshJwt\", \"handle\", \"did\"],\n            properties: {\n              accessJwt: {\n                type: \"string\"\n              },\n              refreshJwt: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidHandle\"\n          },\n          {\n            name: \"InvalidPassword\"\n          },\n          {\n            name: \"InvalidInviteCode\"\n          },\n          {\n            name: \"HandleNotAvailable\"\n          },\n          {\n            name: \"UnsupportedDomain\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerCreateAppPassword: {\n    lexicon: 1,\n    id: \"com.atproto.server.createAppPassword\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an app-specific password.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"name\"],\n            properties: {\n              name: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.server.createAppPassword#appPassword\"\n          }\n        },\n        errors: [\n          {\n            name: \"AccountTakedown\"\n          }\n        ]\n      },\n      appPassword: {\n        type: \"object\",\n        required: [\"name\", \"password\", \"createdAt\"],\n        properties: {\n          name: {\n            type: \"string\"\n          },\n          password: {\n            type: \"string\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateInviteCode: {\n    lexicon: 1,\n    id: \"com.atproto.server.createInviteCode\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an invite code.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"useCount\"],\n            properties: {\n              useCount: {\n                type: \"integer\"\n              },\n              forAccount: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"code\"],\n            properties: {\n              code: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.server.createInviteCodes\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an invite code.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codeCount\", \"useCount\"],\n            properties: {\n              codeCount: {\n                type: \"integer\",\n                default: 1\n              },\n              useCount: {\n                type: \"integer\"\n              },\n              forAccounts: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"did\"\n                }\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codes\"],\n            properties: {\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.server.createInviteCodes#accountCodes\"\n                }\n              }\n            }\n          }\n        }\n      },\n      accountCodes: {\n        type: \"object\",\n        required: [\"account\", \"codes\"],\n        properties: {\n          account: {\n            type: \"string\"\n          },\n          codes: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.createSession\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an authentication session.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"identifier\", \"password\"],\n            properties: {\n              identifier: {\n                type: \"string\",\n                description: \"Handle or other identifier supported by the server for the authenticating user.\"\n              },\n              password: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"accessJwt\", \"refreshJwt\", \"handle\", \"did\"],\n            properties: {\n              accessJwt: {\n                type: \"string\"\n              },\n              refreshJwt: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"AccountTakedown\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerDefs: {\n    lexicon: 1,\n    id: \"com.atproto.server.defs\",\n    defs: {\n      inviteCode: {\n        type: \"object\",\n        required: [\n          \"code\",\n          \"available\",\n          \"disabled\",\n          \"forAccount\",\n          \"createdBy\",\n          \"createdAt\",\n          \"uses\"\n        ],\n        properties: {\n          code: {\n            type: \"string\"\n          },\n          available: {\n            type: \"integer\"\n          },\n          disabled: {\n            type: \"boolean\"\n          },\n          forAccount: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          uses: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.server.defs#inviteCodeUse\"\n            }\n          }\n        }\n      },\n      inviteCodeUse: {\n        type: \"object\",\n        required: [\"usedBy\", \"usedAt\"],\n        properties: {\n          usedBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          usedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerDeleteAccount: {\n    lexicon: 1,\n    id: \"com.atproto.server.deleteAccount\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Delete a user account with a token and password.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"did\", \"password\", \"token\"],\n            properties: {\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              password: {\n                type: \"string\"\n              },\n              token: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"ExpiredToken\"\n          },\n          {\n            name: \"InvalidToken\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerDeleteSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.deleteSession\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Delete the current session.\"\n      }\n    }\n  },\n  ComAtprotoServerDescribeServer: {\n    lexicon: 1,\n    id: \"com.atproto.server.describeServer\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a document describing the service's accounts configuration.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"availableUserDomains\"],\n            properties: {\n              inviteCodeRequired: {\n                type: \"boolean\"\n              },\n              availableUserDomains: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              links: {\n                type: \"ref\",\n                ref: \"lex:com.atproto.server.describeServer#links\"\n              }\n            }\n          }\n        }\n      },\n      links: {\n        type: \"object\",\n        properties: {\n          privacyPolicy: {\n            type: \"string\"\n          },\n          termsOfService: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerGetAccountInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.server.getAccountInviteCodes\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get all invite codes for a given account\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            includeUsed: {\n              type: \"boolean\",\n              default: true\n            },\n            createAvailable: {\n              type: \"boolean\",\n              default: true\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codes\"],\n            properties: {\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.server.defs#inviteCode\"\n                }\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"DuplicateCreate\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerGetSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.getSession\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get information about the current session.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"handle\", \"did\"],\n            properties: {\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerListAppPasswords: {\n    lexicon: 1,\n    id: \"com.atproto.server.listAppPasswords\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List all app-specific passwords.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"passwords\"],\n            properties: {\n              passwords: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.server.listAppPasswords#appPassword\"\n                }\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"AccountTakedown\"\n          }\n        ]\n      },\n      appPassword: {\n        type: \"object\",\n        required: [\"name\", \"createdAt\"],\n        properties: {\n          name: {\n            type: \"string\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerRefreshSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.refreshSession\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Refresh an authentication session.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"accessJwt\", \"refreshJwt\", \"handle\", \"did\"],\n            properties: {\n              accessJwt: {\n                type: \"string\"\n              },\n              refreshJwt: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"AccountTakedown\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerRequestAccountDelete: {\n    lexicon: 1,\n    id: \"com.atproto.server.requestAccountDelete\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Initiate a user account deletion via email.\"\n      }\n    }\n  },\n  ComAtprotoServerRequestPasswordReset: {\n    lexicon: 1,\n    id: \"com.atproto.server.requestPasswordReset\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Initiate a user account password reset via email.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"email\"],\n            properties: {\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerResetPassword: {\n    lexicon: 1,\n    id: \"com.atproto.server.resetPassword\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Reset a user account password using a token.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"token\", \"password\"],\n            properties: {\n              token: {\n                type: \"string\"\n              },\n              password: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"ExpiredToken\"\n          },\n          {\n            name: \"InvalidToken\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerRevokeAppPassword: {\n    lexicon: 1,\n    id: \"com.atproto.server.revokeAppPassword\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Revoke an app-specific password by name.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"name\"],\n            properties: {\n              name: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetBlob: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getBlob\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a blob associated with a given repo.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\", \"cid\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The CID of the blob to fetch\"\n            }\n          }\n        },\n        output: {\n          encoding: \"*/*\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetBlocks: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getBlocks\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets blocks from a given repo.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\", \"cids\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            cids: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetCheckout: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getCheckout\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the repo state.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            commit: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The commit to get the checkout from. Defaults to current HEAD.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetCommitPath: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getCommitPath\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the path of repo commits\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            latest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The most recent commit\"\n            },\n            earliest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The earliest commit to start from\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"commits\"],\n            properties: {\n              commits: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"cid\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetHead: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getHead\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the current HEAD CID of a repo.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"root\"],\n            properties: {\n              root: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetRecord: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getRecord\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets blocks needed for existence or non-existence of record.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\", \"collection\", \"rkey\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            collection: {\n              type: \"string\",\n              format: \"nsid\"\n            },\n            rkey: {\n              type: \"string\"\n            },\n            commit: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"An optional past commit CID.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetRepo: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getRepo\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the repo state.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            earliest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The earliest commit in the commit range (not inclusive)\"\n            },\n            latest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The latest commit in the commit range (inclusive)\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncListBlobs: {\n    lexicon: 1,\n    id: \"com.atproto.sync.listBlobs\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List blob cids for some range of commits\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            latest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The most recent commit\"\n            },\n            earliest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The earliest commit to start from\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"cids\"],\n            properties: {\n              cids: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"cid\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncListRepos: {\n    lexicon: 1,\n    id: \"com.atproto.sync.listRepos\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List dids and root cids of hosted repos\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 1e3,\n              default: 500\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repos\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              repos: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.sync.listRepos#repo\"\n                }\n              }\n            }\n          }\n        }\n      },\n      repo: {\n        type: \"object\",\n        required: [\"did\", \"head\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          head: {\n            type: \"string\",\n            format: \"cid\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncNotifyOfUpdate: {\n    lexicon: 1,\n    id: \"com.atproto.sync.notifyOfUpdate\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Notify a crawling service of a recent update. Often when a long break between updates causes the connection with the crawling service to break.\",\n        parameters: {\n          type: \"params\",\n          required: [\"hostname\"],\n          properties: {\n            hostname: {\n              type: \"string\",\n              description: \"Hostname of the service that is notifying of update.\"\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncRequestCrawl: {\n    lexicon: 1,\n    id: \"com.atproto.sync.requestCrawl\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Request a service to persistently crawl hosted repos.\",\n        parameters: {\n          type: \"params\",\n          required: [\"hostname\"],\n          properties: {\n            hostname: {\n              type: \"string\",\n              description: \"Hostname of the service that is requesting to be crawled.\"\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncSubscribeRepos: {\n    lexicon: 1,\n    id: \"com.atproto.sync.subscribeRepos\",\n    defs: {\n      main: {\n        type: \"subscription\",\n        description: \"Subscribe to repo updates\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            cursor: {\n              type: \"integer\",\n              description: \"The last known event to backfill from.\"\n            }\n          }\n        },\n        message: {\n          schema: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.sync.subscribeRepos#commit\",\n              \"lex:com.atproto.sync.subscribeRepos#handle\",\n              \"lex:com.atproto.sync.subscribeRepos#migrate\",\n              \"lex:com.atproto.sync.subscribeRepos#tombstone\",\n              \"lex:com.atproto.sync.subscribeRepos#info\"\n            ]\n          }\n        },\n        errors: [\n          {\n            name: \"FutureCursor\"\n          }\n        ]\n      },\n      commit: {\n        type: \"object\",\n        required: [\n          \"seq\",\n          \"rebase\",\n          \"tooBig\",\n          \"repo\",\n          \"commit\",\n          \"prev\",\n          \"blocks\",\n          \"ops\",\n          \"blobs\",\n          \"time\"\n        ],\n        nullable: [\"prev\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          rebase: {\n            type: \"boolean\"\n          },\n          tooBig: {\n            type: \"boolean\"\n          },\n          repo: {\n            type: \"string\",\n            format: \"did\"\n          },\n          commit: {\n            type: \"cid-link\"\n          },\n          prev: {\n            type: \"cid-link\"\n          },\n          blocks: {\n            type: \"bytes\",\n            description: \"CAR file containing relevant blocks\",\n            maxLength: 1e6\n          },\n          ops: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.sync.subscribeRepos#repoOp\"\n            },\n            maxLength: 200\n          },\n          blobs: {\n            type: \"array\",\n            items: {\n              type: \"cid-link\"\n            }\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      handle: {\n        type: \"object\",\n        required: [\"seq\", \"did\", \"handle\", \"time\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      migrate: {\n        type: \"object\",\n        required: [\"seq\", \"did\", \"migrateTo\", \"time\"],\n        nullable: [\"migrateTo\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          migrateTo: {\n            type: \"string\"\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      tombstone: {\n        type: \"object\",\n        required: [\"seq\", \"did\", \"time\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      info: {\n        type: \"object\",\n        required: [\"name\"],\n        properties: {\n          name: {\n            type: \"string\",\n            knownValues: [\"OutdatedCursor\"]\n          },\n          message: {\n            type: \"string\"\n          }\n        }\n      },\n      repoOp: {\n        type: \"object\",\n        required: [\"action\", \"path\", \"cid\"],\n        nullable: [\"cid\"],\n        properties: {\n          action: {\n            type: \"string\",\n            knownValues: [\"create\", \"update\", \"delete\"]\n          },\n          path: {\n            type: \"string\"\n          },\n          cid: {\n            type: \"cid-link\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorDefs: {\n    lexicon: 1,\n    id: \"app.bsky.actor.defs\",\n    description: \"A reference to an actor in the network.\",\n    defs: {\n      profileViewBasic: {\n        type: \"object\",\n        required: [\"did\", \"handle\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          displayName: {\n            type: \"string\",\n            maxGraphemes: 64,\n            maxLength: 640\n          },\n          avatar: {\n            type: \"string\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      profileView: {\n        type: \"object\",\n        required: [\"did\", \"handle\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          displayName: {\n            type: \"string\",\n            maxGraphemes: 64,\n            maxLength: 640\n          },\n          description: {\n            type: \"string\",\n            maxGraphemes: 256,\n            maxLength: 2560\n          },\n          avatar: {\n            type: \"string\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      profileViewDetailed: {\n        type: \"object\",\n        required: [\"did\", \"handle\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          displayName: {\n            type: \"string\",\n            maxGraphemes: 64,\n            maxLength: 640\n          },\n          description: {\n            type: \"string\",\n            maxGraphemes: 256,\n            maxLength: 2560\n          },\n          avatar: {\n            type: \"string\"\n          },\n          banner: {\n            type: \"string\"\n          },\n          followersCount: {\n            type: \"integer\"\n          },\n          followsCount: {\n            type: \"integer\"\n          },\n          postsCount: {\n            type: \"integer\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      viewerState: {\n        type: \"object\",\n        properties: {\n          muted: {\n            type: \"boolean\"\n          },\n          blockedBy: {\n            type: \"boolean\"\n          },\n          blocking: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          following: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          followedBy: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorGetProfile: {\n    lexicon: 1,\n    id: \"app.bsky.actor.getProfile\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewDetailed\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorGetProfiles: {\n    lexicon: 1,\n    id: \"app.bsky.actor.getProfiles\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"actors\"],\n          properties: {\n            actors: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"at-identifier\"\n              },\n              maxLength: 25\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"profiles\"],\n            properties: {\n              profiles: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileViewDetailed\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorGetSuggestions: {\n    lexicon: 1,\n    id: \"app.bsky.actor.getSuggestions\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a list of actors suggested for following. Used in discovery UIs.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actors\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              actors: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorProfile: {\n    lexicon: 1,\n    id: \"app.bsky.actor.profile\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"literal:self\",\n        record: {\n          type: \"object\",\n          properties: {\n            displayName: {\n              type: \"string\",\n              maxGraphemes: 64,\n              maxLength: 640\n            },\n            description: {\n              type: \"string\",\n              maxGraphemes: 256,\n              maxLength: 2560\n            },\n            avatar: {\n              type: \"blob\",\n              accept: [\"image/png\", \"image/jpeg\"],\n              maxSize: 1e6\n            },\n            banner: {\n              type: \"blob\",\n              accept: [\"image/png\", \"image/jpeg\"],\n              maxSize: 1e6\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorSearchActors: {\n    lexicon: 1,\n    id: \"app.bsky.actor.searchActors\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find actors matching search criteria.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            term: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actors\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              actors: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorSearchActorsTypeahead: {\n    lexicon: 1,\n    id: \"app.bsky.actor.searchActorsTypeahead\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find actor suggestions for a search term.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            term: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actors\"],\n            properties: {\n              actors: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedExternal: {\n    lexicon: 1,\n    id: \"app.bsky.embed.external\",\n    description: \"A representation of some externally linked content, embedded in another form of content\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"external\"],\n        properties: {\n          external: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.external#external\"\n          }\n        }\n      },\n      external: {\n        type: \"object\",\n        required: [\"uri\", \"title\", \"description\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"uri\"\n          },\n          title: {\n            type: \"string\"\n          },\n          description: {\n            type: \"string\"\n          },\n          thumb: {\n            type: \"blob\",\n            accept: [\"image/*\"],\n            maxSize: 1e6\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"external\"],\n        properties: {\n          external: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.external#viewExternal\"\n          }\n        }\n      },\n      viewExternal: {\n        type: \"object\",\n        required: [\"uri\", \"title\", \"description\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"uri\"\n          },\n          title: {\n            type: \"string\"\n          },\n          description: {\n            type: \"string\"\n          },\n          thumb: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedImages: {\n    lexicon: 1,\n    id: \"app.bsky.embed.images\",\n    description: \"A set of images embedded in some other form of content\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"images\"],\n        properties: {\n          images: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:app.bsky.embed.images#image\"\n            },\n            maxLength: 4\n          }\n        }\n      },\n      image: {\n        type: \"object\",\n        required: [\"image\", \"alt\"],\n        properties: {\n          image: {\n            type: \"blob\",\n            accept: [\"image/*\"],\n            maxSize: 1e6\n          },\n          alt: {\n            type: \"string\"\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"images\"],\n        properties: {\n          images: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:app.bsky.embed.images#viewImage\"\n            },\n            maxLength: 4\n          }\n        }\n      },\n      viewImage: {\n        type: \"object\",\n        required: [\"thumb\", \"fullsize\", \"alt\"],\n        properties: {\n          thumb: {\n            type: \"string\"\n          },\n          fullsize: {\n            type: \"string\"\n          },\n          alt: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedRecord: {\n    lexicon: 1,\n    id: \"app.bsky.embed.record\",\n    description: \"A representation of a record embedded in another form of content\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"record\"],\n        properties: {\n          record: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.repo.strongRef\"\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"record\"],\n        properties: {\n          record: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.embed.record#viewRecord\",\n              \"lex:app.bsky.embed.record#viewNotFound\",\n              \"lex:app.bsky.embed.record#viewBlocked\"\n            ]\n          }\n        }\n      },\n      viewRecord: {\n        type: \"object\",\n        required: [\"uri\", \"cid\", \"author\", \"value\", \"indexedAt\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          author: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n          },\n          value: {\n            type: \"unknown\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          },\n          embeds: {\n            type: \"array\",\n            items: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.embed.images#view\",\n                \"lex:app.bsky.embed.external#view\",\n                \"lex:app.bsky.embed.record#view\",\n                \"lex:app.bsky.embed.recordWithMedia#view\"\n              ]\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      viewNotFound: {\n        type: \"object\",\n        required: [\"uri\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      },\n      viewBlocked: {\n        type: \"object\",\n        required: [\"uri\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedRecordWithMedia: {\n    lexicon: 1,\n    id: \"app.bsky.embed.recordWithMedia\",\n    description: \"A representation of a record embedded in another form of content, alongside other compatible embeds\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"record\", \"media\"],\n        properties: {\n          record: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.record\"\n          },\n          media: {\n            type: \"union\",\n            refs: [\"lex:app.bsky.embed.images\", \"lex:app.bsky.embed.external\"]\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"record\", \"media\"],\n        properties: {\n          record: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.record#view\"\n          },\n          media: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.embed.images#view\",\n              \"lex:app.bsky.embed.external#view\"\n            ]\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedDefs: {\n    lexicon: 1,\n    id: \"app.bsky.feed.defs\",\n    defs: {\n      postView: {\n        type: \"object\",\n        required: [\"uri\", \"cid\", \"author\", \"record\", \"indexedAt\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          author: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n          },\n          record: {\n            type: \"unknown\"\n          },\n          embed: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.embed.images#view\",\n              \"lex:app.bsky.embed.external#view\",\n              \"lex:app.bsky.embed.record#view\",\n              \"lex:app.bsky.embed.recordWithMedia#view\"\n            ]\n          },\n          replyCount: {\n            type: \"integer\"\n          },\n          repostCount: {\n            type: \"integer\"\n          },\n          likeCount: {\n            type: \"integer\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      viewerState: {\n        type: \"object\",\n        properties: {\n          repost: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          like: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      },\n      feedViewPost: {\n        type: \"object\",\n        required: [\"post\"],\n        properties: {\n          post: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          },\n          reply: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#replyRef\"\n          },\n          reason: {\n            type: \"union\",\n            refs: [\"lex:app.bsky.feed.defs#reasonRepost\"]\n          }\n        }\n      },\n      replyRef: {\n        type: \"object\",\n        required: [\"root\", \"parent\"],\n        properties: {\n          root: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          },\n          parent: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          }\n        }\n      },\n      reasonRepost: {\n        type: \"object\",\n        required: [\"by\", \"indexedAt\"],\n        properties: {\n          by: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      threadViewPost: {\n        type: \"object\",\n        required: [\"post\"],\n        properties: {\n          post: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          },\n          parent: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.feed.defs#threadViewPost\",\n              \"lex:app.bsky.feed.defs#notFoundPost\",\n              \"lex:app.bsky.feed.defs#blockedPost\"\n            ]\n          },\n          replies: {\n            type: \"array\",\n            items: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.feed.defs#threadViewPost\",\n                \"lex:app.bsky.feed.defs#notFoundPost\",\n                \"lex:app.bsky.feed.defs#blockedPost\"\n              ]\n            }\n          }\n        }\n      },\n      notFoundPost: {\n        type: \"object\",\n        required: [\"uri\", \"notFound\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          notFound: {\n            type: \"boolean\",\n            const: true\n          }\n        }\n      },\n      blockedPost: {\n        type: \"object\",\n        required: [\"uri\", \"blocked\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          blocked: {\n            type: \"boolean\",\n            const: true\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetAuthorFeed: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getAuthorFeed\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"A view of an actor's feed.\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"feed\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              feed: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#feedViewPost\"\n                }\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"BlockedActor\"\n          },\n          {\n            name: \"BlockedByActor\"\n          }\n        ]\n      }\n    }\n  },\n  AppBskyFeedGetLikes: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getLikes\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"likes\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              likes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.getLikes#like\"\n                }\n              }\n            }\n          }\n        }\n      },\n      like: {\n        type: \"object\",\n        required: [\"indexedAt\", \"createdAt\", \"actor\"],\n        properties: {\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          actor: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileView\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetPostThread: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getPostThread\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            depth: {\n              type: \"integer\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"thread\"],\n            properties: {\n              thread: {\n                type: \"union\",\n                refs: [\n                  \"lex:app.bsky.feed.defs#threadViewPost\",\n                  \"lex:app.bsky.feed.defs#notFoundPost\",\n                  \"lex:app.bsky.feed.defs#blockedPost\"\n                ]\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"NotFound\"\n          }\n        ]\n      }\n    }\n  },\n  AppBskyFeedGetPosts: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getPosts\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"A view of an actor's feed.\",\n        parameters: {\n          type: \"params\",\n          required: [\"uris\"],\n          properties: {\n            uris: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              maxLength: 25\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"posts\"],\n            properties: {\n              posts: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#postView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetRepostedBy: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getRepostedBy\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"repostedBy\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              repostedBy: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetTimeline: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getTimeline\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"A view of the user's home timeline.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            algorithm: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"feed\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              feed: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#feedViewPost\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedLike: {\n    lexicon: 1,\n    id: \"app.bsky.feed.like\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.repo.strongRef\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedPost: {\n    lexicon: 1,\n    id: \"app.bsky.feed.post\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"text\", \"createdAt\"],\n          properties: {\n            text: {\n              type: \"string\",\n              maxLength: 3e3,\n              maxGraphemes: 300\n            },\n            entities: {\n              type: \"array\",\n              description: \"Deprecated: replaced by app.bsky.richtext.facet.\",\n              items: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.feed.post#entity\"\n              }\n            },\n            facets: {\n              type: \"array\",\n              items: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.richtext.facet\"\n              }\n            },\n            reply: {\n              type: \"ref\",\n              ref: \"lex:app.bsky.feed.post#replyRef\"\n            },\n            embed: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.embed.images\",\n                \"lex:app.bsky.embed.external\",\n                \"lex:app.bsky.embed.record\",\n                \"lex:app.bsky.embed.recordWithMedia\"\n              ]\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      },\n      replyRef: {\n        type: \"object\",\n        required: [\"root\", \"parent\"],\n        properties: {\n          root: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.repo.strongRef\"\n          },\n          parent: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.repo.strongRef\"\n          }\n        }\n      },\n      entity: {\n        type: \"object\",\n        description: \"Deprecated: use facets instead.\",\n        required: [\"index\", \"type\", \"value\"],\n        properties: {\n          index: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.post#textSlice\"\n          },\n          type: {\n            type: \"string\",\n            description: \"Expected values are 'mention' and 'link'.\"\n          },\n          value: {\n            type: \"string\"\n          }\n        }\n      },\n      textSlice: {\n        type: \"object\",\n        description: \"Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.\",\n        required: [\"start\", \"end\"],\n        properties: {\n          start: {\n            type: \"integer\",\n            minimum: 0\n          },\n          end: {\n            type: \"integer\",\n            minimum: 0\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedRepost: {\n    lexicon: 1,\n    id: \"app.bsky.feed.repost\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.repo.strongRef\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphBlock: {\n    lexicon: 1,\n    id: \"app.bsky.graph.block\",\n    defs: {\n      main: {\n        type: \"record\",\n        description: \"A block.\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"string\",\n              format: \"did\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphFollow: {\n    lexicon: 1,\n    id: \"app.bsky.graph.follow\",\n    defs: {\n      main: {\n        type: \"record\",\n        description: \"A social follow.\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"string\",\n              format: \"did\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetBlocks: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getBlocks\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who is the requester's account blocking?\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"blocks\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              blocks: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetFollowers: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getFollowers\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who is following an actor?\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"subject\", \"followers\"],\n            properties: {\n              subject: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.actor.defs#profileView\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              followers: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetFollows: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getFollows\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who is an actor following?\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"subject\", \"follows\"],\n            properties: {\n              subject: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.actor.defs#profileView\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              follows: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetMutes: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getMutes\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who does the viewer mute?\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"mutes\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              mutes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphMuteActor: {\n    lexicon: 1,\n    id: \"app.bsky.graph.muteActor\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Mute an actor by did or handle.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actor\"],\n            properties: {\n              actor: {\n                type: \"string\",\n                format: \"at-identifier\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphUnmuteActor: {\n    lexicon: 1,\n    id: \"app.bsky.graph.unmuteActor\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Unmute an actor by did or handle.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actor\"],\n            properties: {\n              actor: {\n                type: \"string\",\n                format: \"at-identifier\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyNotificationGetUnreadCount: {\n    lexicon: 1,\n    id: \"app.bsky.notification.getUnreadCount\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            seenAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"count\"],\n            properties: {\n              count: {\n                type: \"integer\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyNotificationListNotifications: {\n    lexicon: 1,\n    id: \"app.bsky.notification.listNotifications\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            },\n            seenAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"notifications\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              notifications: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.notification.listNotifications#notification\"\n                }\n              }\n            }\n          }\n        }\n      },\n      notification: {\n        type: \"object\",\n        required: [\n          \"uri\",\n          \"cid\",\n          \"author\",\n          \"reason\",\n          \"record\",\n          \"isRead\",\n          \"indexedAt\"\n        ],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          author: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileView\"\n          },\n          reason: {\n            type: \"string\",\n            description: \"Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.\",\n            knownValues: [\n              \"like\",\n              \"repost\",\n              \"follow\",\n              \"mention\",\n              \"reply\",\n              \"quote\"\n            ]\n          },\n          reasonSubject: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          record: {\n            type: \"unknown\"\n          },\n          isRead: {\n            type: \"boolean\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyNotificationUpdateSeen: {\n    lexicon: 1,\n    id: \"app.bsky.notification.updateSeen\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Notify server that the user has seen notifications.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"seenAt\"],\n            properties: {\n              seenAt: {\n                type: \"string\",\n                format: \"datetime\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyRichtextFacet: {\n    lexicon: 1,\n    id: \"app.bsky.richtext.facet\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"index\", \"features\"],\n        properties: {\n          index: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.richtext.facet#byteSlice\"\n          },\n          features: {\n            type: \"array\",\n            items: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.richtext.facet#mention\",\n                \"lex:app.bsky.richtext.facet#link\"\n              ]\n            }\n          }\n        }\n      },\n      mention: {\n        type: \"object\",\n        description: \"A facet feature for actor mentions.\",\n        required: [\"did\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          }\n        }\n      },\n      link: {\n        type: \"object\",\n        description: \"A facet feature for links.\",\n        required: [\"uri\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"uri\"\n          }\n        }\n      },\n      byteSlice: {\n        type: \"object\",\n        description: \"A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.\",\n        required: [\"byteStart\", \"byteEnd\"],\n        properties: {\n          byteStart: {\n            type: \"integer\",\n            minimum: 0\n          },\n          byteEnd: {\n            type: \"integer\",\n            minimum: 0\n          }\n        }\n      }\n    }\n  },\n  AppBskyUnspeccedGetPopular: {\n    lexicon: 1,\n    id: \"app.bsky.unspecced.getPopular\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"An unspecced view of globally popular items\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"feed\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              feed: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#feedViewPost\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\nvar schemas = Object.values(schemaDict);\nvar lexicons = new Lexicons(schemas);\n\n// src/client/types/com/atproto/admin/disableInviteCodes.ts\nvar disableInviteCodes_exports = {};\n__export(disableInviteCodes_exports, {\n  toKnownErr: () => toKnownErr\n});\nfunction toKnownErr(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getInviteCodes.ts\nvar getInviteCodes_exports = {};\n__export(getInviteCodes_exports, {\n  toKnownErr: () => toKnownErr2\n});\nfunction toKnownErr2(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationAction.ts\nvar getModerationAction_exports = {};\n__export(getModerationAction_exports, {\n  toKnownErr: () => toKnownErr3\n});\nfunction toKnownErr3(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationActions.ts\nvar getModerationActions_exports = {};\n__export(getModerationActions_exports, {\n  toKnownErr: () => toKnownErr4\n});\nfunction toKnownErr4(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationReport.ts\nvar getModerationReport_exports = {};\n__export(getModerationReport_exports, {\n  toKnownErr: () => toKnownErr5\n});\nfunction toKnownErr5(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationReports.ts\nvar getModerationReports_exports = {};\n__export(getModerationReports_exports, {\n  toKnownErr: () => toKnownErr6\n});\nfunction toKnownErr6(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getRecord.ts\nvar getRecord_exports = {};\n__export(getRecord_exports, {\n  toKnownErr: () => toKnownErr7\n});\nfunction toKnownErr7(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getRepo.ts\nvar getRepo_exports = {};\n__export(getRepo_exports, {\n  toKnownErr: () => toKnownErr8\n});\nfunction toKnownErr8(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/resolveModerationReports.ts\nvar resolveModerationReports_exports = {};\n__export(resolveModerationReports_exports, {\n  toKnownErr: () => toKnownErr9\n});\nfunction toKnownErr9(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/reverseModerationAction.ts\nvar reverseModerationAction_exports = {};\n__export(reverseModerationAction_exports, {\n  toKnownErr: () => toKnownErr10\n});\nfunction toKnownErr10(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/searchRepos.ts\nvar searchRepos_exports = {};\n__export(searchRepos_exports, {\n  toKnownErr: () => toKnownErr11\n});\nfunction toKnownErr11(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/takeModerationAction.ts\nvar takeModerationAction_exports = {};\n__export(takeModerationAction_exports, {\n  SubjectHasActionError: () => SubjectHasActionError,\n  toKnownErr: () => toKnownErr12\n});\nvar SubjectHasActionError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr12(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"SubjectHasAction\")\n      return new SubjectHasActionError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/updateAccountEmail.ts\nvar updateAccountEmail_exports = {};\n__export(updateAccountEmail_exports, {\n  toKnownErr: () => toKnownErr13\n});\nfunction toKnownErr13(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/updateAccountHandle.ts\nvar updateAccountHandle_exports = {};\n__export(updateAccountHandle_exports, {\n  toKnownErr: () => toKnownErr14\n});\nfunction toKnownErr14(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/identity/resolveHandle.ts\nvar resolveHandle_exports = {};\n__export(resolveHandle_exports, {\n  toKnownErr: () => toKnownErr15\n});\nfunction toKnownErr15(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/identity/updateHandle.ts\nvar updateHandle_exports = {};\n__export(updateHandle_exports, {\n  toKnownErr: () => toKnownErr16\n});\nfunction toKnownErr16(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/label/queryLabels.ts\nvar queryLabels_exports = {};\n__export(queryLabels_exports, {\n  toKnownErr: () => toKnownErr17\n});\nfunction toKnownErr17(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/moderation/createReport.ts\nvar createReport_exports = {};\n__export(createReport_exports, {\n  toKnownErr: () => toKnownErr18\n});\nfunction toKnownErr18(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/applyWrites.ts\nvar applyWrites_exports = {};\n__export(applyWrites_exports, {\n  InvalidSwapError: () => InvalidSwapError,\n  isCreate: () => isCreate,\n  isDelete: () => isDelete,\n  isUpdate: () => isUpdate,\n  toKnownErr: () => toKnownErr19,\n  validateCreate: () => validateCreate,\n  validateDelete: () => validateDelete,\n  validateUpdate: () => validateUpdate\n});\n\n// src/client/util.ts\nfunction isObj2(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction hasProp2(data, prop) {\n  return prop in data;\n}\n\n// src/client/types/com/atproto/repo/applyWrites.ts\nvar InvalidSwapError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr19(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError(e);\n  }\n  return e;\n}\nfunction isCreate(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.applyWrites#create\";\n}\nfunction validateCreate(v) {\n  return lexicons.validate(\"com.atproto.repo.applyWrites#create\", v);\n}\nfunction isUpdate(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.applyWrites#update\";\n}\nfunction validateUpdate(v) {\n  return lexicons.validate(\"com.atproto.repo.applyWrites#update\", v);\n}\nfunction isDelete(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.applyWrites#delete\";\n}\nfunction validateDelete(v) {\n  return lexicons.validate(\"com.atproto.repo.applyWrites#delete\", v);\n}\n\n// src/client/types/com/atproto/repo/createRecord.ts\nvar createRecord_exports = {};\n__export(createRecord_exports, {\n  InvalidSwapError: () => InvalidSwapError2,\n  toKnownErr: () => toKnownErr20\n});\nvar InvalidSwapError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr20(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError2(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/deleteRecord.ts\nvar deleteRecord_exports = {};\n__export(deleteRecord_exports, {\n  InvalidSwapError: () => InvalidSwapError3,\n  toKnownErr: () => toKnownErr21\n});\nvar InvalidSwapError3 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr21(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError3(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/describeRepo.ts\nvar describeRepo_exports = {};\n__export(describeRepo_exports, {\n  toKnownErr: () => toKnownErr22\n});\nfunction toKnownErr22(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/getRecord.ts\nvar getRecord_exports2 = {};\n__export(getRecord_exports2, {\n  toKnownErr: () => toKnownErr23\n});\nfunction toKnownErr23(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/listRecords.ts\nvar listRecords_exports = {};\n__export(listRecords_exports, {\n  isRecord: () => isRecord,\n  toKnownErr: () => toKnownErr24,\n  validateRecord: () => validateRecord\n});\nfunction toKnownErr24(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isRecord(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.listRecords#record\";\n}\nfunction validateRecord(v) {\n  return lexicons.validate(\"com.atproto.repo.listRecords#record\", v);\n}\n\n// src/client/types/com/atproto/repo/putRecord.ts\nvar putRecord_exports = {};\n__export(putRecord_exports, {\n  InvalidSwapError: () => InvalidSwapError4,\n  toKnownErr: () => toKnownErr25\n});\nvar InvalidSwapError4 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr25(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError4(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/uploadBlob.ts\nvar uploadBlob_exports = {};\n__export(uploadBlob_exports, {\n  toKnownErr: () => toKnownErr26\n});\nfunction toKnownErr26(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createAccount.ts\nvar createAccount_exports = {};\n__export(createAccount_exports, {\n  HandleNotAvailableError: () => HandleNotAvailableError,\n  InvalidHandleError: () => InvalidHandleError2,\n  InvalidInviteCodeError: () => InvalidInviteCodeError,\n  InvalidPasswordError: () => InvalidPasswordError,\n  UnsupportedDomainError: () => UnsupportedDomainError,\n  toKnownErr: () => toKnownErr27\n});\nvar InvalidHandleError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidPasswordError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidInviteCodeError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar HandleNotAvailableError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar UnsupportedDomainError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr27(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidHandle\")\n      return new InvalidHandleError2(e);\n    if (e.error === \"InvalidPassword\")\n      return new InvalidPasswordError(e);\n    if (e.error === \"InvalidInviteCode\")\n      return new InvalidInviteCodeError(e);\n    if (e.error === \"HandleNotAvailable\")\n      return new HandleNotAvailableError(e);\n    if (e.error === \"UnsupportedDomain\")\n      return new UnsupportedDomainError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createAppPassword.ts\nvar createAppPassword_exports = {};\n__export(createAppPassword_exports, {\n  AccountTakedownError: () => AccountTakedownError,\n  isAppPassword: () => isAppPassword,\n  toKnownErr: () => toKnownErr28,\n  validateAppPassword: () => validateAppPassword\n});\nvar AccountTakedownError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr28(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"AccountTakedown\")\n      return new AccountTakedownError(e);\n  }\n  return e;\n}\nfunction isAppPassword(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.createAppPassword#appPassword\";\n}\nfunction validateAppPassword(v) {\n  return lexicons.validate(\n    \"com.atproto.server.createAppPassword#appPassword\",\n    v\n  );\n}\n\n// src/client/types/com/atproto/server/createInviteCode.ts\nvar createInviteCode_exports = {};\n__export(createInviteCode_exports, {\n  toKnownErr: () => toKnownErr29\n});\nfunction toKnownErr29(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createInviteCodes.ts\nvar createInviteCodes_exports = {};\n__export(createInviteCodes_exports, {\n  isAccountCodes: () => isAccountCodes,\n  toKnownErr: () => toKnownErr30,\n  validateAccountCodes: () => validateAccountCodes\n});\nfunction toKnownErr30(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isAccountCodes(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.createInviteCodes#accountCodes\";\n}\nfunction validateAccountCodes(v) {\n  return lexicons.validate(\n    \"com.atproto.server.createInviteCodes#accountCodes\",\n    v\n  );\n}\n\n// src/client/types/com/atproto/server/createSession.ts\nvar createSession_exports = {};\n__export(createSession_exports, {\n  AccountTakedownError: () => AccountTakedownError2,\n  toKnownErr: () => toKnownErr31\n});\nvar AccountTakedownError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr31(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"AccountTakedown\")\n      return new AccountTakedownError2(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/deleteAccount.ts\nvar deleteAccount_exports = {};\n__export(deleteAccount_exports, {\n  ExpiredTokenError: () => ExpiredTokenError,\n  InvalidTokenError: () => InvalidTokenError,\n  toKnownErr: () => toKnownErr32\n});\nvar ExpiredTokenError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidTokenError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr32(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"ExpiredToken\")\n      return new ExpiredTokenError(e);\n    if (e.error === \"InvalidToken\")\n      return new InvalidTokenError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/deleteSession.ts\nvar deleteSession_exports = {};\n__export(deleteSession_exports, {\n  toKnownErr: () => toKnownErr33\n});\nfunction toKnownErr33(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/describeServer.ts\nvar describeServer_exports = {};\n__export(describeServer_exports, {\n  isLinks: () => isLinks,\n  toKnownErr: () => toKnownErr34,\n  validateLinks: () => validateLinks\n});\nfunction toKnownErr34(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isLinks(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.describeServer#links\";\n}\nfunction validateLinks(v) {\n  return lexicons.validate(\"com.atproto.server.describeServer#links\", v);\n}\n\n// src/client/types/com/atproto/server/getAccountInviteCodes.ts\nvar getAccountInviteCodes_exports = {};\n__export(getAccountInviteCodes_exports, {\n  DuplicateCreateError: () => DuplicateCreateError,\n  toKnownErr: () => toKnownErr35\n});\nvar DuplicateCreateError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr35(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"DuplicateCreate\")\n      return new DuplicateCreateError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/getSession.ts\nvar getSession_exports = {};\n__export(getSession_exports, {\n  toKnownErr: () => toKnownErr36\n});\nfunction toKnownErr36(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/listAppPasswords.ts\nvar listAppPasswords_exports = {};\n__export(listAppPasswords_exports, {\n  AccountTakedownError: () => AccountTakedownError3,\n  isAppPassword: () => isAppPassword2,\n  toKnownErr: () => toKnownErr37,\n  validateAppPassword: () => validateAppPassword2\n});\nvar AccountTakedownError3 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr37(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"AccountTakedown\")\n      return new AccountTakedownError3(e);\n  }\n  return e;\n}\nfunction isAppPassword2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.listAppPasswords#appPassword\";\n}\nfunction validateAppPassword2(v) {\n  return lexicons.validate(\"com.atproto.server.listAppPasswords#appPassword\", v);\n}\n\n// src/client/types/com/atproto/server/refreshSession.ts\nvar refreshSession_exports = {};\n__export(refreshSession_exports, {\n  AccountTakedownError: () => AccountTakedownError4,\n  toKnownErr: () => toKnownErr38\n});\nvar AccountTakedownError4 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr38(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"AccountTakedown\")\n      return new AccountTakedownError4(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/requestAccountDelete.ts\nvar requestAccountDelete_exports = {};\n__export(requestAccountDelete_exports, {\n  toKnownErr: () => toKnownErr39\n});\nfunction toKnownErr39(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/requestPasswordReset.ts\nvar requestPasswordReset_exports = {};\n__export(requestPasswordReset_exports, {\n  toKnownErr: () => toKnownErr40\n});\nfunction toKnownErr40(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/resetPassword.ts\nvar resetPassword_exports = {};\n__export(resetPassword_exports, {\n  ExpiredTokenError: () => ExpiredTokenError2,\n  InvalidTokenError: () => InvalidTokenError2,\n  toKnownErr: () => toKnownErr41\n});\nvar ExpiredTokenError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidTokenError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr41(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"ExpiredToken\")\n      return new ExpiredTokenError2(e);\n    if (e.error === \"InvalidToken\")\n      return new InvalidTokenError2(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/revokeAppPassword.ts\nvar revokeAppPassword_exports = {};\n__export(revokeAppPassword_exports, {\n  toKnownErr: () => toKnownErr42\n});\nfunction toKnownErr42(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getBlob.ts\nvar getBlob_exports = {};\n__export(getBlob_exports, {\n  toKnownErr: () => toKnownErr43\n});\nfunction toKnownErr43(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getBlocks.ts\nvar getBlocks_exports = {};\n__export(getBlocks_exports, {\n  toKnownErr: () => toKnownErr44\n});\nfunction toKnownErr44(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getCheckout.ts\nvar getCheckout_exports = {};\n__export(getCheckout_exports, {\n  toKnownErr: () => toKnownErr45\n});\nfunction toKnownErr45(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getCommitPath.ts\nvar getCommitPath_exports = {};\n__export(getCommitPath_exports, {\n  toKnownErr: () => toKnownErr46\n});\nfunction toKnownErr46(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getHead.ts\nvar getHead_exports = {};\n__export(getHead_exports, {\n  toKnownErr: () => toKnownErr47\n});\nfunction toKnownErr47(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getRecord.ts\nvar getRecord_exports3 = {};\n__export(getRecord_exports3, {\n  toKnownErr: () => toKnownErr48\n});\nfunction toKnownErr48(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getRepo.ts\nvar getRepo_exports2 = {};\n__export(getRepo_exports2, {\n  toKnownErr: () => toKnownErr49\n});\nfunction toKnownErr49(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/listBlobs.ts\nvar listBlobs_exports = {};\n__export(listBlobs_exports, {\n  toKnownErr: () => toKnownErr50\n});\nfunction toKnownErr50(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/listRepos.ts\nvar listRepos_exports = {};\n__export(listRepos_exports, {\n  isRepo: () => isRepo,\n  toKnownErr: () => toKnownErr51,\n  validateRepo: () => validateRepo\n});\nfunction toKnownErr51(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isRepo(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.listRepos#repo\";\n}\nfunction validateRepo(v) {\n  return lexicons.validate(\"com.atproto.sync.listRepos#repo\", v);\n}\n\n// src/client/types/com/atproto/sync/notifyOfUpdate.ts\nvar notifyOfUpdate_exports = {};\n__export(notifyOfUpdate_exports, {\n  toKnownErr: () => toKnownErr52\n});\nfunction toKnownErr52(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/requestCrawl.ts\nvar requestCrawl_exports = {};\n__export(requestCrawl_exports, {\n  toKnownErr: () => toKnownErr53\n});\nfunction toKnownErr53(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/getProfile.ts\nvar getProfile_exports = {};\n__export(getProfile_exports, {\n  toKnownErr: () => toKnownErr54\n});\nfunction toKnownErr54(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/getProfiles.ts\nvar getProfiles_exports = {};\n__export(getProfiles_exports, {\n  toKnownErr: () => toKnownErr55\n});\nfunction toKnownErr55(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/getSuggestions.ts\nvar getSuggestions_exports = {};\n__export(getSuggestions_exports, {\n  toKnownErr: () => toKnownErr56\n});\nfunction toKnownErr56(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/searchActors.ts\nvar searchActors_exports = {};\n__export(searchActors_exports, {\n  toKnownErr: () => toKnownErr57\n});\nfunction toKnownErr57(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/searchActorsTypeahead.ts\nvar searchActorsTypeahead_exports = {};\n__export(searchActorsTypeahead_exports, {\n  toKnownErr: () => toKnownErr58\n});\nfunction toKnownErr58(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getAuthorFeed.ts\nvar getAuthorFeed_exports = {};\n__export(getAuthorFeed_exports, {\n  BlockedActorError: () => BlockedActorError,\n  BlockedByActorError: () => BlockedByActorError,\n  toKnownErr: () => toKnownErr59\n});\nvar BlockedActorError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar BlockedByActorError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr59(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"BlockedActor\")\n      return new BlockedActorError(e);\n    if (e.error === \"BlockedByActor\")\n      return new BlockedByActorError(e);\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getLikes.ts\nvar getLikes_exports = {};\n__export(getLikes_exports, {\n  isLike: () => isLike,\n  toKnownErr: () => toKnownErr60,\n  validateLike: () => validateLike\n});\nfunction toKnownErr60(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isLike(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.getLikes#like\";\n}\nfunction validateLike(v) {\n  return lexicons.validate(\"app.bsky.feed.getLikes#like\", v);\n}\n\n// src/client/types/app/bsky/feed/getPostThread.ts\nvar getPostThread_exports = {};\n__export(getPostThread_exports, {\n  NotFoundError: () => NotFoundError,\n  toKnownErr: () => toKnownErr61\n});\nvar NotFoundError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr61(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"NotFound\")\n      return new NotFoundError(e);\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getPosts.ts\nvar getPosts_exports = {};\n__export(getPosts_exports, {\n  toKnownErr: () => toKnownErr62\n});\nfunction toKnownErr62(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getRepostedBy.ts\nvar getRepostedBy_exports = {};\n__export(getRepostedBy_exports, {\n  toKnownErr: () => toKnownErr63\n});\nfunction toKnownErr63(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getTimeline.ts\nvar getTimeline_exports = {};\n__export(getTimeline_exports, {\n  toKnownErr: () => toKnownErr64\n});\nfunction toKnownErr64(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getBlocks.ts\nvar getBlocks_exports2 = {};\n__export(getBlocks_exports2, {\n  toKnownErr: () => toKnownErr65\n});\nfunction toKnownErr65(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getFollowers.ts\nvar getFollowers_exports = {};\n__export(getFollowers_exports, {\n  toKnownErr: () => toKnownErr66\n});\nfunction toKnownErr66(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getFollows.ts\nvar getFollows_exports = {};\n__export(getFollows_exports, {\n  toKnownErr: () => toKnownErr67\n});\nfunction toKnownErr67(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getMutes.ts\nvar getMutes_exports = {};\n__export(getMutes_exports, {\n  toKnownErr: () => toKnownErr68\n});\nfunction toKnownErr68(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/muteActor.ts\nvar muteActor_exports = {};\n__export(muteActor_exports, {\n  toKnownErr: () => toKnownErr69\n});\nfunction toKnownErr69(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/unmuteActor.ts\nvar unmuteActor_exports = {};\n__export(unmuteActor_exports, {\n  toKnownErr: () => toKnownErr70\n});\nfunction toKnownErr70(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/notification/getUnreadCount.ts\nvar getUnreadCount_exports = {};\n__export(getUnreadCount_exports, {\n  toKnownErr: () => toKnownErr71\n});\nfunction toKnownErr71(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/notification/listNotifications.ts\nvar listNotifications_exports = {};\n__export(listNotifications_exports, {\n  isNotification: () => isNotification,\n  toKnownErr: () => toKnownErr72,\n  validateNotification: () => validateNotification\n});\nfunction toKnownErr72(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isNotification(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.notification.listNotifications#notification\";\n}\nfunction validateNotification(v) {\n  return lexicons.validate(\n    \"app.bsky.notification.listNotifications#notification\",\n    v\n  );\n}\n\n// src/client/types/app/bsky/notification/updateSeen.ts\nvar updateSeen_exports = {};\n__export(updateSeen_exports, {\n  toKnownErr: () => toKnownErr73\n});\nfunction toKnownErr73(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/unspecced/getPopular.ts\nvar getPopular_exports = {};\n__export(getPopular_exports, {\n  toKnownErr: () => toKnownErr74\n});\nfunction toKnownErr74(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/defs.ts\nvar defs_exports = {};\n__export(defs_exports, {\n  ACKNOWLEDGE: () => ACKNOWLEDGE,\n  FLAG: () => FLAG,\n  TAKEDOWN: () => TAKEDOWN,\n  isActionReversal: () => isActionReversal,\n  isActionView: () => isActionView,\n  isActionViewCurrent: () => isActionViewCurrent,\n  isActionViewDetail: () => isActionViewDetail,\n  isBlobView: () => isBlobView,\n  isImageDetails: () => isImageDetails,\n  isModeration: () => isModeration,\n  isModerationDetail: () => isModerationDetail,\n  isRecordView: () => isRecordView,\n  isRecordViewDetail: () => isRecordViewDetail,\n  isRepoRef: () => isRepoRef,\n  isRepoView: () => isRepoView,\n  isRepoViewDetail: () => isRepoViewDetail,\n  isReportView: () => isReportView,\n  isReportViewDetail: () => isReportViewDetail,\n  isVideoDetails: () => isVideoDetails,\n  validateActionReversal: () => validateActionReversal,\n  validateActionView: () => validateActionView,\n  validateActionViewCurrent: () => validateActionViewCurrent,\n  validateActionViewDetail: () => validateActionViewDetail,\n  validateBlobView: () => validateBlobView,\n  validateImageDetails: () => validateImageDetails,\n  validateModeration: () => validateModeration,\n  validateModerationDetail: () => validateModerationDetail,\n  validateRecordView: () => validateRecordView,\n  validateRecordViewDetail: () => validateRecordViewDetail,\n  validateRepoRef: () => validateRepoRef,\n  validateRepoView: () => validateRepoView,\n  validateRepoViewDetail: () => validateRepoViewDetail,\n  validateReportView: () => validateReportView,\n  validateReportViewDetail: () => validateReportViewDetail,\n  validateVideoDetails: () => validateVideoDetails\n});\nfunction isActionView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionView\";\n}\nfunction validateActionView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionView\", v);\n}\nfunction isActionViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionViewDetail\";\n}\nfunction validateActionViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionViewDetail\", v);\n}\nfunction isActionViewCurrent(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionViewCurrent\";\n}\nfunction validateActionViewCurrent(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionViewCurrent\", v);\n}\nfunction isActionReversal(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionReversal\";\n}\nfunction validateActionReversal(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionReversal\", v);\n}\nvar TAKEDOWN = \"com.atproto.admin.defs#takedown\";\nvar FLAG = \"com.atproto.admin.defs#flag\";\nvar ACKNOWLEDGE = \"com.atproto.admin.defs#acknowledge\";\nfunction isReportView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#reportView\";\n}\nfunction validateReportView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#reportView\", v);\n}\nfunction isReportViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#reportViewDetail\";\n}\nfunction validateReportViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#reportViewDetail\", v);\n}\nfunction isRepoView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#repoView\";\n}\nfunction validateRepoView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#repoView\", v);\n}\nfunction isRepoViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#repoViewDetail\";\n}\nfunction validateRepoViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#repoViewDetail\", v);\n}\nfunction isRepoRef(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#repoRef\";\n}\nfunction validateRepoRef(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#repoRef\", v);\n}\nfunction isRecordView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#recordView\";\n}\nfunction validateRecordView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#recordView\", v);\n}\nfunction isRecordViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#recordViewDetail\";\n}\nfunction validateRecordViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#recordViewDetail\", v);\n}\nfunction isModeration(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#moderation\";\n}\nfunction validateModeration(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#moderation\", v);\n}\nfunction isModerationDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#moderationDetail\";\n}\nfunction validateModerationDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#moderationDetail\", v);\n}\nfunction isBlobView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#blobView\";\n}\nfunction validateBlobView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#blobView\", v);\n}\nfunction isImageDetails(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#imageDetails\";\n}\nfunction validateImageDetails(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#imageDetails\", v);\n}\nfunction isVideoDetails(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#videoDetails\";\n}\nfunction validateVideoDetails(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#videoDetails\", v);\n}\n\n// src/client/types/com/atproto/label/defs.ts\nvar defs_exports2 = {};\n__export(defs_exports2, {\n  isLabel: () => isLabel,\n  validateLabel: () => validateLabel\n});\nfunction isLabel(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.label.defs#label\";\n}\nfunction validateLabel(v) {\n  return lexicons.validate(\"com.atproto.label.defs#label\", v);\n}\n\n// src/client/types/com/atproto/label/subscribeLabels.ts\nvar subscribeLabels_exports = {};\n__export(subscribeLabels_exports, {\n  isInfo: () => isInfo,\n  isLabels: () => isLabels,\n  validateInfo: () => validateInfo,\n  validateLabels: () => validateLabels\n});\nfunction isLabels(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.label.subscribeLabels#labels\";\n}\nfunction validateLabels(v) {\n  return lexicons.validate(\"com.atproto.label.subscribeLabels#labels\", v);\n}\nfunction isInfo(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.label.subscribeLabels#info\";\n}\nfunction validateInfo(v) {\n  return lexicons.validate(\"com.atproto.label.subscribeLabels#info\", v);\n}\n\n// src/client/types/com/atproto/moderation/defs.ts\nvar defs_exports3 = {};\n__export(defs_exports3, {\n  REASONMISLEADING: () => REASONMISLEADING,\n  REASONOTHER: () => REASONOTHER,\n  REASONRUDE: () => REASONRUDE,\n  REASONSEXUAL: () => REASONSEXUAL,\n  REASONSPAM: () => REASONSPAM,\n  REASONVIOLATION: () => REASONVIOLATION\n});\nvar REASONSPAM = \"com.atproto.moderation.defs#reasonSpam\";\nvar REASONVIOLATION = \"com.atproto.moderation.defs#reasonViolation\";\nvar REASONMISLEADING = \"com.atproto.moderation.defs#reasonMisleading\";\nvar REASONSEXUAL = \"com.atproto.moderation.defs#reasonSexual\";\nvar REASONRUDE = \"com.atproto.moderation.defs#reasonRude\";\nvar REASONOTHER = \"com.atproto.moderation.defs#reasonOther\";\n\n// src/client/types/com/atproto/repo/strongRef.ts\nvar strongRef_exports = {};\n__export(strongRef_exports, {\n  isMain: () => isMain,\n  validateMain: () => validateMain\n});\nfunction isMain(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"com.atproto.repo.strongRef#main\" || v.$type === \"com.atproto.repo.strongRef\");\n}\nfunction validateMain(v) {\n  return lexicons.validate(\"com.atproto.repo.strongRef#main\", v);\n}\n\n// src/client/types/com/atproto/server/defs.ts\nvar defs_exports4 = {};\n__export(defs_exports4, {\n  isInviteCode: () => isInviteCode,\n  isInviteCodeUse: () => isInviteCodeUse,\n  validateInviteCode: () => validateInviteCode,\n  validateInviteCodeUse: () => validateInviteCodeUse\n});\nfunction isInviteCode(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.defs#inviteCode\";\n}\nfunction validateInviteCode(v) {\n  return lexicons.validate(\"com.atproto.server.defs#inviteCode\", v);\n}\nfunction isInviteCodeUse(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.defs#inviteCodeUse\";\n}\nfunction validateInviteCodeUse(v) {\n  return lexicons.validate(\"com.atproto.server.defs#inviteCodeUse\", v);\n}\n\n// src/client/types/com/atproto/sync/subscribeRepos.ts\nvar subscribeRepos_exports = {};\n__export(subscribeRepos_exports, {\n  isCommit: () => isCommit,\n  isHandle: () => isHandle,\n  isInfo: () => isInfo2,\n  isMigrate: () => isMigrate,\n  isRepoOp: () => isRepoOp,\n  isTombstone: () => isTombstone,\n  validateCommit: () => validateCommit,\n  validateHandle: () => validateHandle,\n  validateInfo: () => validateInfo2,\n  validateMigrate: () => validateMigrate,\n  validateRepoOp: () => validateRepoOp,\n  validateTombstone: () => validateTombstone\n});\nfunction isCommit(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#commit\";\n}\nfunction validateCommit(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#commit\", v);\n}\nfunction isHandle(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#handle\";\n}\nfunction validateHandle(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#handle\", v);\n}\nfunction isMigrate(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#migrate\";\n}\nfunction validateMigrate(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#migrate\", v);\n}\nfunction isTombstone(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#tombstone\";\n}\nfunction validateTombstone(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#tombstone\", v);\n}\nfunction isInfo2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#info\";\n}\nfunction validateInfo2(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#info\", v);\n}\nfunction isRepoOp(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#repoOp\";\n}\nfunction validateRepoOp(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#repoOp\", v);\n}\n\n// src/client/types/app/bsky/actor/defs.ts\nvar defs_exports5 = {};\n__export(defs_exports5, {\n  isProfileView: () => isProfileView,\n  isProfileViewBasic: () => isProfileViewBasic,\n  isProfileViewDetailed: () => isProfileViewDetailed,\n  isViewerState: () => isViewerState,\n  validateProfileView: () => validateProfileView,\n  validateProfileViewBasic: () => validateProfileViewBasic,\n  validateProfileViewDetailed: () => validateProfileViewDetailed,\n  validateViewerState: () => validateViewerState\n});\nfunction isProfileViewBasic(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#profileViewBasic\";\n}\nfunction validateProfileViewBasic(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#profileViewBasic\", v);\n}\nfunction isProfileView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#profileView\";\n}\nfunction validateProfileView(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#profileView\", v);\n}\nfunction isProfileViewDetailed(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#profileViewDetailed\";\n}\nfunction validateProfileViewDetailed(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#profileViewDetailed\", v);\n}\nfunction isViewerState(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#viewerState\";\n}\nfunction validateViewerState(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#viewerState\", v);\n}\n\n// src/client/types/app/bsky/actor/profile.ts\nvar profile_exports = {};\n__export(profile_exports, {\n  isRecord: () => isRecord2,\n  validateRecord: () => validateRecord2\n});\nfunction isRecord2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.actor.profile#main\" || v.$type === \"app.bsky.actor.profile\");\n}\nfunction validateRecord2(v) {\n  return lexicons.validate(\"app.bsky.actor.profile#main\", v);\n}\n\n// src/client/types/app/bsky/embed/external.ts\nvar external_exports = {};\n__export(external_exports, {\n  isExternal: () => isExternal,\n  isMain: () => isMain2,\n  isView: () => isView,\n  isViewExternal: () => isViewExternal,\n  validateExternal: () => validateExternal,\n  validateMain: () => validateMain2,\n  validateView: () => validateView,\n  validateViewExternal: () => validateViewExternal\n});\nfunction isMain2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.external#main\" || v.$type === \"app.bsky.embed.external\");\n}\nfunction validateMain2(v) {\n  return lexicons.validate(\"app.bsky.embed.external#main\", v);\n}\nfunction isExternal(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.external#external\";\n}\nfunction validateExternal(v) {\n  return lexicons.validate(\"app.bsky.embed.external#external\", v);\n}\nfunction isView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.external#view\";\n}\nfunction validateView(v) {\n  return lexicons.validate(\"app.bsky.embed.external#view\", v);\n}\nfunction isViewExternal(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.external#viewExternal\";\n}\nfunction validateViewExternal(v) {\n  return lexicons.validate(\"app.bsky.embed.external#viewExternal\", v);\n}\n\n// src/client/types/app/bsky/embed/images.ts\nvar images_exports = {};\n__export(images_exports, {\n  isImage: () => isImage,\n  isMain: () => isMain3,\n  isView: () => isView2,\n  isViewImage: () => isViewImage,\n  validateImage: () => validateImage,\n  validateMain: () => validateMain3,\n  validateView: () => validateView2,\n  validateViewImage: () => validateViewImage\n});\nfunction isMain3(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.images#main\" || v.$type === \"app.bsky.embed.images\");\n}\nfunction validateMain3(v) {\n  return lexicons.validate(\"app.bsky.embed.images#main\", v);\n}\nfunction isImage(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.images#image\";\n}\nfunction validateImage(v) {\n  return lexicons.validate(\"app.bsky.embed.images#image\", v);\n}\nfunction isView2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.images#view\";\n}\nfunction validateView2(v) {\n  return lexicons.validate(\"app.bsky.embed.images#view\", v);\n}\nfunction isViewImage(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.images#viewImage\";\n}\nfunction validateViewImage(v) {\n  return lexicons.validate(\"app.bsky.embed.images#viewImage\", v);\n}\n\n// src/client/types/app/bsky/embed/record.ts\nvar record_exports = {};\n__export(record_exports, {\n  isMain: () => isMain4,\n  isView: () => isView3,\n  isViewBlocked: () => isViewBlocked,\n  isViewNotFound: () => isViewNotFound,\n  isViewRecord: () => isViewRecord,\n  validateMain: () => validateMain4,\n  validateView: () => validateView3,\n  validateViewBlocked: () => validateViewBlocked,\n  validateViewNotFound: () => validateViewNotFound,\n  validateViewRecord: () => validateViewRecord\n});\nfunction isMain4(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.record#main\" || v.$type === \"app.bsky.embed.record\");\n}\nfunction validateMain4(v) {\n  return lexicons.validate(\"app.bsky.embed.record#main\", v);\n}\nfunction isView3(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#view\";\n}\nfunction validateView3(v) {\n  return lexicons.validate(\"app.bsky.embed.record#view\", v);\n}\nfunction isViewRecord(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#viewRecord\";\n}\nfunction validateViewRecord(v) {\n  return lexicons.validate(\"app.bsky.embed.record#viewRecord\", v);\n}\nfunction isViewNotFound(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#viewNotFound\";\n}\nfunction validateViewNotFound(v) {\n  return lexicons.validate(\"app.bsky.embed.record#viewNotFound\", v);\n}\nfunction isViewBlocked(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#viewBlocked\";\n}\nfunction validateViewBlocked(v) {\n  return lexicons.validate(\"app.bsky.embed.record#viewBlocked\", v);\n}\n\n// src/client/types/app/bsky/embed/recordWithMedia.ts\nvar recordWithMedia_exports = {};\n__export(recordWithMedia_exports, {\n  isMain: () => isMain5,\n  isView: () => isView4,\n  validateMain: () => validateMain5,\n  validateView: () => validateView4\n});\nfunction isMain5(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.recordWithMedia#main\" || v.$type === \"app.bsky.embed.recordWithMedia\");\n}\nfunction validateMain5(v) {\n  return lexicons.validate(\"app.bsky.embed.recordWithMedia#main\", v);\n}\nfunction isView4(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.recordWithMedia#view\";\n}\nfunction validateView4(v) {\n  return lexicons.validate(\"app.bsky.embed.recordWithMedia#view\", v);\n}\n\n// src/client/types/app/bsky/feed/defs.ts\nvar defs_exports6 = {};\n__export(defs_exports6, {\n  isBlockedPost: () => isBlockedPost,\n  isFeedViewPost: () => isFeedViewPost,\n  isNotFoundPost: () => isNotFoundPost,\n  isPostView: () => isPostView,\n  isReasonRepost: () => isReasonRepost,\n  isReplyRef: () => isReplyRef,\n  isThreadViewPost: () => isThreadViewPost,\n  isViewerState: () => isViewerState2,\n  validateBlockedPost: () => validateBlockedPost,\n  validateFeedViewPost: () => validateFeedViewPost,\n  validateNotFoundPost: () => validateNotFoundPost,\n  validatePostView: () => validatePostView,\n  validateReasonRepost: () => validateReasonRepost,\n  validateReplyRef: () => validateReplyRef,\n  validateThreadViewPost: () => validateThreadViewPost,\n  validateViewerState: () => validateViewerState2\n});\nfunction isPostView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#postView\";\n}\nfunction validatePostView(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#postView\", v);\n}\nfunction isViewerState2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#viewerState\";\n}\nfunction validateViewerState2(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#viewerState\", v);\n}\nfunction isFeedViewPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#feedViewPost\";\n}\nfunction validateFeedViewPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#feedViewPost\", v);\n}\nfunction isReplyRef(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#replyRef\";\n}\nfunction validateReplyRef(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#replyRef\", v);\n}\nfunction isReasonRepost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#reasonRepost\";\n}\nfunction validateReasonRepost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#reasonRepost\", v);\n}\nfunction isThreadViewPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#threadViewPost\";\n}\nfunction validateThreadViewPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#threadViewPost\", v);\n}\nfunction isNotFoundPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#notFoundPost\";\n}\nfunction validateNotFoundPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#notFoundPost\", v);\n}\nfunction isBlockedPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#blockedPost\";\n}\nfunction validateBlockedPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#blockedPost\", v);\n}\n\n// src/client/types/app/bsky/feed/like.ts\nvar like_exports = {};\n__export(like_exports, {\n  isRecord: () => isRecord3,\n  validateRecord: () => validateRecord3\n});\nfunction isRecord3(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.feed.like#main\" || v.$type === \"app.bsky.feed.like\");\n}\nfunction validateRecord3(v) {\n  return lexicons.validate(\"app.bsky.feed.like#main\", v);\n}\n\n// src/client/types/app/bsky/feed/post.ts\nvar post_exports = {};\n__export(post_exports, {\n  isEntity: () => isEntity,\n  isRecord: () => isRecord4,\n  isReplyRef: () => isReplyRef2,\n  isTextSlice: () => isTextSlice,\n  validateEntity: () => validateEntity,\n  validateRecord: () => validateRecord4,\n  validateReplyRef: () => validateReplyRef2,\n  validateTextSlice: () => validateTextSlice\n});\nfunction isRecord4(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.feed.post#main\" || v.$type === \"app.bsky.feed.post\");\n}\nfunction validateRecord4(v) {\n  return lexicons.validate(\"app.bsky.feed.post#main\", v);\n}\nfunction isReplyRef2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.post#replyRef\";\n}\nfunction validateReplyRef2(v) {\n  return lexicons.validate(\"app.bsky.feed.post#replyRef\", v);\n}\nfunction isEntity(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.post#entity\";\n}\nfunction validateEntity(v) {\n  return lexicons.validate(\"app.bsky.feed.post#entity\", v);\n}\nfunction isTextSlice(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.post#textSlice\";\n}\nfunction validateTextSlice(v) {\n  return lexicons.validate(\"app.bsky.feed.post#textSlice\", v);\n}\n\n// src/client/types/app/bsky/feed/repost.ts\nvar repost_exports = {};\n__export(repost_exports, {\n  isRecord: () => isRecord5,\n  validateRecord: () => validateRecord5\n});\nfunction isRecord5(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.feed.repost#main\" || v.$type === \"app.bsky.feed.repost\");\n}\nfunction validateRecord5(v) {\n  return lexicons.validate(\"app.bsky.feed.repost#main\", v);\n}\n\n// src/client/types/app/bsky/graph/block.ts\nvar block_exports = {};\n__export(block_exports, {\n  isRecord: () => isRecord6,\n  validateRecord: () => validateRecord6\n});\nfunction isRecord6(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.graph.block#main\" || v.$type === \"app.bsky.graph.block\");\n}\nfunction validateRecord6(v) {\n  return lexicons.validate(\"app.bsky.graph.block#main\", v);\n}\n\n// src/client/types/app/bsky/graph/follow.ts\nvar follow_exports = {};\n__export(follow_exports, {\n  isRecord: () => isRecord7,\n  validateRecord: () => validateRecord7\n});\nfunction isRecord7(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.graph.follow#main\" || v.$type === \"app.bsky.graph.follow\");\n}\nfunction validateRecord7(v) {\n  return lexicons.validate(\"app.bsky.graph.follow#main\", v);\n}\n\n// src/client/types/app/bsky/richtext/facet.ts\nvar facet_exports = {};\n__export(facet_exports, {\n  isByteSlice: () => isByteSlice,\n  isLink: () => isLink,\n  isMain: () => isMain6,\n  isMention: () => isMention,\n  validateByteSlice: () => validateByteSlice,\n  validateLink: () => validateLink,\n  validateMain: () => validateMain6,\n  validateMention: () => validateMention\n});\nfunction isMain6(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.richtext.facet#main\" || v.$type === \"app.bsky.richtext.facet\");\n}\nfunction validateMain6(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#main\", v);\n}\nfunction isMention(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.richtext.facet#mention\";\n}\nfunction validateMention(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#mention\", v);\n}\nfunction isLink(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.richtext.facet#link\";\n}\nfunction validateLink(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#link\", v);\n}\nfunction isByteSlice(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.richtext.facet#byteSlice\";\n}\nfunction validateByteSlice(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#byteSlice\", v);\n}\n\n// src/client/index.ts\nvar COM_ATPROTO_ADMIN = {\n  DefsTakedown: \"com.atproto.admin.defs#takedown\",\n  DefsFlag: \"com.atproto.admin.defs#flag\",\n  DefsAcknowledge: \"com.atproto.admin.defs#acknowledge\"\n};\nvar COM_ATPROTO_MODERATION = {\n  DefsReasonSpam: \"com.atproto.moderation.defs#reasonSpam\",\n  DefsReasonViolation: \"com.atproto.moderation.defs#reasonViolation\",\n  DefsReasonMisleading: \"com.atproto.moderation.defs#reasonMisleading\",\n  DefsReasonSexual: \"com.atproto.moderation.defs#reasonSexual\",\n  DefsReasonRude: \"com.atproto.moderation.defs#reasonRude\",\n  DefsReasonOther: \"com.atproto.moderation.defs#reasonOther\"\n};\nvar AtpBaseClient = class {\n  constructor() {\n    this.xrpc = new Client();\n    this.xrpc.addLexicons(schemas);\n  }\n  service(serviceUri) {\n    return new AtpServiceClient(this, this.xrpc.service(serviceUri));\n  }\n};\nvar AtpServiceClient = class {\n  constructor(baseClient, xrpcService) {\n    this._baseClient = baseClient;\n    this.xrpc = xrpcService;\n    this.com = new ComNS(this);\n    this.app = new AppNS(this);\n  }\n  setHeader(key, value) {\n    this.xrpc.setHeader(key, value);\n  }\n};\nvar ComNS = class {\n  constructor(service) {\n    this._service = service;\n    this.atproto = new AtprotoNS(service);\n  }\n};\nvar AtprotoNS = class {\n  constructor(service) {\n    this._service = service;\n    this.admin = new AdminNS(service);\n    this.identity = new IdentityNS(service);\n    this.label = new LabelNS(service);\n    this.moderation = new ModerationNS(service);\n    this.repo = new RepoNS(service);\n    this.server = new ServerNS(service);\n    this.sync = new SyncNS(service);\n  }\n};\nvar AdminNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  disableInviteCodes(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.disableInviteCodes\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr(e);\n    });\n  }\n  getInviteCodes(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getInviteCodes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr2(e);\n    });\n  }\n  getModerationAction(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationAction\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr3(e);\n    });\n  }\n  getModerationActions(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationActions\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr4(e);\n    });\n  }\n  getModerationReport(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationReport\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr5(e);\n    });\n  }\n  getModerationReports(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationReports\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr6(e);\n    });\n  }\n  getRecord(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getRecord\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr7(e);\n    });\n  }\n  getRepo(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getRepo\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr8(e);\n    });\n  }\n  resolveModerationReports(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.resolveModerationReports\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr9(e);\n    });\n  }\n  reverseModerationAction(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.reverseModerationAction\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr10(e);\n    });\n  }\n  searchRepos(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.searchRepos\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr11(e);\n    });\n  }\n  takeModerationAction(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.takeModerationAction\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr12(e);\n    });\n  }\n  updateAccountEmail(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.updateAccountEmail\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr13(e);\n    });\n  }\n  updateAccountHandle(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.updateAccountHandle\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr14(e);\n    });\n  }\n};\nvar IdentityNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  resolveHandle(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.identity.resolveHandle\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr15(e);\n    });\n  }\n  updateHandle(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.identity.updateHandle\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr16(e);\n    });\n  }\n};\nvar LabelNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  queryLabels(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.label.queryLabels\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr17(e);\n    });\n  }\n};\nvar ModerationNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  createReport(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.moderation.createReport\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr18(e);\n    });\n  }\n};\nvar RepoNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  applyWrites(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.applyWrites\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr19(e);\n    });\n  }\n  createRecord(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.createRecord\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr20(e);\n    });\n  }\n  deleteRecord(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.deleteRecord\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr21(e);\n    });\n  }\n  describeRepo(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.describeRepo\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr22(e);\n    });\n  }\n  getRecord(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.getRecord\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr23(e);\n    });\n  }\n  listRecords(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.listRecords\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr24(e);\n    });\n  }\n  putRecord(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.putRecord\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr25(e);\n    });\n  }\n  uploadBlob(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.uploadBlob\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr26(e);\n    });\n  }\n};\nvar ServerNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  createAccount(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createAccount\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr27(e);\n    });\n  }\n  createAppPassword(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createAppPassword\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr28(e);\n    });\n  }\n  createInviteCode(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createInviteCode\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr29(e);\n    });\n  }\n  createInviteCodes(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createInviteCodes\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr30(e);\n    });\n  }\n  createSession(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createSession\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr31(e);\n    });\n  }\n  deleteAccount(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.deleteAccount\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr32(e);\n    });\n  }\n  deleteSession(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.deleteSession\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr33(e);\n    });\n  }\n  describeServer(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.describeServer\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr34(e);\n    });\n  }\n  getAccountInviteCodes(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.getAccountInviteCodes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr35(e);\n    });\n  }\n  getSession(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.getSession\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr36(e);\n    });\n  }\n  listAppPasswords(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.listAppPasswords\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr37(e);\n    });\n  }\n  refreshSession(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.refreshSession\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr38(e);\n    });\n  }\n  requestAccountDelete(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.requestAccountDelete\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr39(e);\n    });\n  }\n  requestPasswordReset(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.requestPasswordReset\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr40(e);\n    });\n  }\n  resetPassword(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.resetPassword\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr41(e);\n    });\n  }\n  revokeAppPassword(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.revokeAppPassword\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr42(e);\n    });\n  }\n};\nvar SyncNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  getBlob(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getBlob\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr43(e);\n    });\n  }\n  getBlocks(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getBlocks\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr44(e);\n    });\n  }\n  getCheckout(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getCheckout\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr45(e);\n    });\n  }\n  getCommitPath(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getCommitPath\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr46(e);\n    });\n  }\n  getHead(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getHead\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr47(e);\n    });\n  }\n  getRecord(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getRecord\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr48(e);\n    });\n  }\n  getRepo(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getRepo\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr49(e);\n    });\n  }\n  listBlobs(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.listBlobs\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr50(e);\n    });\n  }\n  listRepos(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.listRepos\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr51(e);\n    });\n  }\n  notifyOfUpdate(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.notifyOfUpdate\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr52(e);\n    });\n  }\n  requestCrawl(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.requestCrawl\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr53(e);\n    });\n  }\n};\nvar AppNS = class {\n  constructor(service) {\n    this._service = service;\n    this.bsky = new BskyNS(service);\n  }\n};\nvar BskyNS = class {\n  constructor(service) {\n    this._service = service;\n    this.actor = new ActorNS(service);\n    this.embed = new EmbedNS(service);\n    this.feed = new FeedNS(service);\n    this.graph = new GraphNS(service);\n    this.notification = new NotificationNS(service);\n    this.richtext = new RichtextNS(service);\n    this.unspecced = new UnspeccedNS(service);\n  }\n};\nvar ActorNS = class {\n  constructor(service) {\n    this._service = service;\n    this.profile = new ProfileRecord(service);\n  }\n  getProfile(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.getProfile\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr54(e);\n    });\n  }\n  getProfiles(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.getProfiles\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr55(e);\n    });\n  }\n  getSuggestions(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.getSuggestions\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr56(e);\n    });\n  }\n  searchActors(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.searchActors\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr57(e);\n    });\n  }\n  searchActorsTypeahead(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.searchActorsTypeahead\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr58(e);\n    });\n  }\n};\nvar ProfileRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.actor.profile\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.actor.profile\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.actor.profile\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.actor.profile\", rkey: \"self\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.actor.profile\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar EmbedNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n};\nvar FeedNS = class {\n  constructor(service) {\n    this._service = service;\n    this.like = new LikeRecord(service);\n    this.post = new PostRecord(service);\n    this.repost = new RepostRecord(service);\n  }\n  getAuthorFeed(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getAuthorFeed\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr59(e);\n    });\n  }\n  getLikes(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getLikes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr60(e);\n    });\n  }\n  getPostThread(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getPostThread\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr61(e);\n    });\n  }\n  getPosts(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getPosts\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr62(e);\n    });\n  }\n  getRepostedBy(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getRepostedBy\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr63(e);\n    });\n  }\n  getTimeline(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getTimeline\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr64(e);\n    });\n  }\n};\nvar LikeRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.feed.like\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.feed.like\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.feed.like\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.like\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.like\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar PostRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.feed.post\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.feed.post\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.feed.post\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.post\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.post\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar RepostRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.feed.repost\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.feed.repost\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.feed.repost\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.repost\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.repost\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar GraphNS = class {\n  constructor(service) {\n    this._service = service;\n    this.block = new BlockRecord(service);\n    this.follow = new FollowRecord(service);\n  }\n  getBlocks(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getBlocks\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr65(e);\n    });\n  }\n  getFollowers(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getFollowers\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr66(e);\n    });\n  }\n  getFollows(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getFollows\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr67(e);\n    });\n  }\n  getMutes(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getMutes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr68(e);\n    });\n  }\n  muteActor(data, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.muteActor\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr69(e);\n    });\n  }\n  unmuteActor(data, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.unmuteActor\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr70(e);\n    });\n  }\n};\nvar BlockRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.graph.block\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.graph.block\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.graph.block\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.graph.block\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.graph.block\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar FollowRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.graph.follow\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.graph.follow\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.graph.follow\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.graph.follow\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.graph.follow\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar NotificationNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  getUnreadCount(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.notification.getUnreadCount\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr71(e);\n    });\n  }\n  listNotifications(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.notification.listNotifications\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr72(e);\n    });\n  }\n  updateSeen(data, opts) {\n    return this._service.xrpc.call(\"app.bsky.notification.updateSeen\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr73(e);\n    });\n  }\n};\nvar RichtextNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n};\nvar UnspeccedNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  getPopular(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.unspecced.getPopular\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr74(e);\n    });\n  }\n};\n\n// src/agent.ts\nvar REFRESH_SESSION = \"com.atproto.server.refreshSession\";\nvar _AtpAgent = class {\n  constructor(opts) {\n    this.uploadBlob = (data, opts) => this.api.com.atproto.repo.uploadBlob(data, opts);\n    this.resolveHandle = (params2, opts) => this.api.com.atproto.identity.resolveHandle(params2, opts);\n    this.updateHandle = (data, opts) => this.api.com.atproto.identity.updateHandle(data, opts);\n    this.createModerationReport = (data, opts) => this.api.com.atproto.moderation.createReport(data, opts);\n    this.service = opts.service instanceof URL ? opts.service : new URL(opts.service);\n    this._persistSession = opts.persistSession;\n    this._baseClient = new AtpBaseClient();\n    this._baseClient.xrpc.fetch = this._fetch.bind(this);\n    this.api = this._baseClient.service(opts.service);\n  }\n  get com() {\n    return this.api.com;\n  }\n  static configure(opts) {\n    _AtpAgent.fetch = opts.fetch;\n  }\n  get hasSession() {\n    return !!this.session;\n  }\n  setPersistSessionHandler(handler) {\n    this._persistSession = handler;\n  }\n  async createAccount(opts) {\n    try {\n      const res = await this.api.com.atproto.server.createAccount({\n        handle: opts.handle,\n        password: opts.password,\n        email: opts.email,\n        inviteCode: opts.inviteCode\n      });\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: opts.email\n      };\n      return res;\n    } catch (e) {\n      this.session = void 0;\n      throw e;\n    } finally {\n      if (this.session) {\n        this._persistSession?.(\"create\", this.session);\n      } else {\n        this._persistSession?.(\"create-failed\", void 0);\n      }\n    }\n  }\n  async login(opts) {\n    try {\n      const res = await this.api.com.atproto.server.createSession({\n        identifier: opts.identifier,\n        password: opts.password\n      });\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: res.data.email\n      };\n      return res;\n    } catch (e) {\n      this.session = void 0;\n      throw e;\n    } finally {\n      if (this.session) {\n        this._persistSession?.(\"create\", this.session);\n      } else {\n        this._persistSession?.(\"create-failed\", void 0);\n      }\n    }\n  }\n  async resumeSession(session) {\n    try {\n      this.session = session;\n      const res = await this.api.com.atproto.server.getSession();\n      if (!res.success || res.data.did !== this.session.did) {\n        throw new Error(\"Invalid session\");\n      }\n      this.session.email = res.data.email;\n      this.session.handle = res.data.handle;\n      return res;\n    } catch (e) {\n      this.session = void 0;\n      throw e;\n    } finally {\n      if (this.session) {\n        this._persistSession?.(\"create\", this.session);\n      } else {\n        this._persistSession?.(\"create-failed\", void 0);\n      }\n    }\n  }\n  _addAuthHeader(reqHeaders) {\n    if (!reqHeaders.authorization && this.session?.accessJwt) {\n      return {\n        ...reqHeaders,\n        authorization: `Bearer ${this.session.accessJwt}`\n      };\n    }\n    return reqHeaders;\n  }\n  async _fetch(reqUri, reqMethod, reqHeaders, reqBody) {\n    if (!_AtpAgent.fetch) {\n      throw new Error(\"AtpAgent fetch() method not configured\");\n    }\n    await this._refreshSessionPromise;\n    let res = await _AtpAgent.fetch(\n      reqUri,\n      reqMethod,\n      this._addAuthHeader(reqHeaders),\n      reqBody\n    );\n    if (isErrorResponse(res, [\"ExpiredToken\"]) && this.session?.refreshJwt) {\n      await this._refreshSession();\n      res = await _AtpAgent.fetch(\n        reqUri,\n        reqMethod,\n        this._addAuthHeader(reqHeaders),\n        reqBody\n      );\n    }\n    return res;\n  }\n  async _refreshSession() {\n    if (this._refreshSessionPromise) {\n      return this._refreshSessionPromise;\n    }\n    this._refreshSessionPromise = this._refreshSessionInner();\n    try {\n      await this._refreshSessionPromise;\n    } finally {\n      this._refreshSessionPromise = void 0;\n    }\n  }\n  async _refreshSessionInner() {\n    if (!_AtpAgent.fetch) {\n      throw new Error(\"AtpAgent fetch() method not configured\");\n    }\n    if (!this.session?.refreshJwt) {\n      return;\n    }\n    const url = new URL(this.service.origin);\n    url.pathname = `/xrpc/${REFRESH_SESSION}`;\n    const res = await _AtpAgent.fetch(\n      url.toString(),\n      \"POST\",\n      {\n        authorization: `Bearer ${this.session.refreshJwt}`\n      },\n      void 0\n    );\n    if (isErrorResponse(res, [\"ExpiredToken\", \"InvalidToken\"])) {\n      this.session = void 0;\n      this._persistSession?.(\"expired\", void 0);\n    } else if (isNewSessionObject(this._baseClient, res.body)) {\n      this.session = {\n        accessJwt: res.body.accessJwt,\n        refreshJwt: res.body.refreshJwt,\n        handle: res.body.handle,\n        did: res.body.did\n      };\n      this._persistSession?.(\"update\", this.session);\n    }\n  }\n};\nvar AtpAgent = _AtpAgent;\nAtpAgent.fetch = defaultFetchHandler;\nfunction isErrorObject(v) {\n  return errorResponseBody.safeParse(v).success;\n}\nfunction isErrorResponse(res, errorNames) {\n  if (res.status !== 400) {\n    return false;\n  }\n  if (!isErrorObject(res.body)) {\n    return false;\n  }\n  return typeof res.body.error === \"string\" && errorNames.includes(res.body.error);\n}\nfunction isNewSessionObject(client, v) {\n  try {\n    client.xrpc.lex.assertValidXrpcOutput(\n      \"com.atproto.server.refreshSession\",\n      v\n    );\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// src/rich-text/unicode.ts\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar UnicodeString = class {\n  constructor(utf16) {\n    this.utf16 = utf16;\n    this.utf8 = encoder.encode(utf16);\n  }\n  get length() {\n    return this.utf8.byteLength;\n  }\n  get graphemeLength() {\n    if (!this._graphemeLen) {\n      this._graphemeLen = graphemeLen(this.utf16);\n    }\n    return this._graphemeLen;\n  }\n  slice(start, end) {\n    return decoder.decode(this.utf8.slice(start, end));\n  }\n  utf16IndexToUtf8Index(i) {\n    return encoder.encode(this.utf16.slice(0, i)).byteLength;\n  }\n  toString() {\n    return this.utf16;\n  }\n};\n\n// src/rich-text/sanitization.ts\nvar EXCESS_SPACE_RE = /[\\r\\n]([\\u00AD\\u2060\\u200D\\u200C\\u200B\\s]*[\\r\\n]){2,}/;\nvar REPLACEMENT_STR = \"\\n\\n\";\nfunction sanitizeRichText(richText, opts) {\n  if (opts.cleanNewlines) {\n    richText = clean(richText, EXCESS_SPACE_RE, REPLACEMENT_STR);\n  }\n  return richText;\n}\nfunction clean(richText, targetRegexp, replacementString) {\n  richText = richText.clone();\n  let match = richText.unicodeText.utf16.match(targetRegexp);\n  while (match && typeof match.index !== \"undefined\") {\n    const oldText = richText.unicodeText;\n    const removeStartIndex = richText.unicodeText.utf16IndexToUtf8Index(\n      match.index\n    );\n    const removeEndIndex = removeStartIndex + new UnicodeString(match[0]).length;\n    richText.delete(removeStartIndex, removeEndIndex);\n    if (richText.unicodeText.utf16 === oldText.utf16) {\n      break;\n    }\n    richText.insert(removeStartIndex, replacementString);\n    match = richText.unicodeText.utf16.match(targetRegexp);\n  }\n  return richText;\n}\n\n// ../../node_modules/tlds/index.json\nvar tlds_default = [\n  \"aaa\",\n  \"aarp\",\n  \"abarth\",\n  \"abb\",\n  \"abbott\",\n  \"abbvie\",\n  \"abc\",\n  \"able\",\n  \"abogado\",\n  \"abudhabi\",\n  \"ac\",\n  \"academy\",\n  \"accenture\",\n  \"accountant\",\n  \"accountants\",\n  \"aco\",\n  \"actor\",\n  \"ad\",\n  \"ads\",\n  \"adult\",\n  \"ae\",\n  \"aeg\",\n  \"aero\",\n  \"aetna\",\n  \"af\",\n  \"afl\",\n  \"africa\",\n  \"ag\",\n  \"agakhan\",\n  \"agency\",\n  \"ai\",\n  \"aig\",\n  \"airbus\",\n  \"airforce\",\n  \"airtel\",\n  \"akdn\",\n  \"al\",\n  \"alfaromeo\",\n  \"alibaba\",\n  \"alipay\",\n  \"allfinanz\",\n  \"allstate\",\n  \"ally\",\n  \"alsace\",\n  \"alstom\",\n  \"am\",\n  \"amazon\",\n  \"americanexpress\",\n  \"americanfamily\",\n  \"amex\",\n  \"amfam\",\n  \"amica\",\n  \"amsterdam\",\n  \"analytics\",\n  \"android\",\n  \"anquan\",\n  \"anz\",\n  \"ao\",\n  \"aol\",\n  \"apartments\",\n  \"app\",\n  \"apple\",\n  \"aq\",\n  \"aquarelle\",\n  \"ar\",\n  \"arab\",\n  \"aramco\",\n  \"archi\",\n  \"army\",\n  \"arpa\",\n  \"art\",\n  \"arte\",\n  \"as\",\n  \"asda\",\n  \"asia\",\n  \"associates\",\n  \"at\",\n  \"athleta\",\n  \"attorney\",\n  \"au\",\n  \"auction\",\n  \"audi\",\n  \"audible\",\n  \"audio\",\n  \"auspost\",\n  \"author\",\n  \"auto\",\n  \"autos\",\n  \"avianca\",\n  \"aw\",\n  \"aws\",\n  \"ax\",\n  \"axa\",\n  \"az\",\n  \"azure\",\n  \"ba\",\n  \"baby\",\n  \"baidu\",\n  \"banamex\",\n  \"bananarepublic\",\n  \"band\",\n  \"bank\",\n  \"bar\",\n  \"barcelona\",\n  \"barclaycard\",\n  \"barclays\",\n  \"barefoot\",\n  \"bargains\",\n  \"baseball\",\n  \"basketball\",\n  \"bauhaus\",\n  \"bayern\",\n  \"bb\",\n  \"bbc\",\n  \"bbt\",\n  \"bbva\",\n  \"bcg\",\n  \"bcn\",\n  \"bd\",\n  \"be\",\n  \"beats\",\n  \"beauty\",\n  \"beer\",\n  \"bentley\",\n  \"berlin\",\n  \"best\",\n  \"bestbuy\",\n  \"bet\",\n  \"bf\",\n  \"bg\",\n  \"bh\",\n  \"bharti\",\n  \"bi\",\n  \"bible\",\n  \"bid\",\n  \"bike\",\n  \"bing\",\n  \"bingo\",\n  \"bio\",\n  \"biz\",\n  \"bj\",\n  \"black\",\n  \"blackfriday\",\n  \"blockbuster\",\n  \"blog\",\n  \"bloomberg\",\n  \"blue\",\n  \"bm\",\n  \"bms\",\n  \"bmw\",\n  \"bn\",\n  \"bnpparibas\",\n  \"bo\",\n  \"boats\",\n  \"boehringer\",\n  \"bofa\",\n  \"bom\",\n  \"bond\",\n  \"boo\",\n  \"book\",\n  \"booking\",\n  \"bosch\",\n  \"bostik\",\n  \"boston\",\n  \"bot\",\n  \"boutique\",\n  \"box\",\n  \"br\",\n  \"bradesco\",\n  \"bridgestone\",\n  \"broadway\",\n  \"broker\",\n  \"brother\",\n  \"brussels\",\n  \"bs\",\n  \"bt\",\n  \"build\",\n  \"builders\",\n  \"business\",\n  \"buy\",\n  \"buzz\",\n  \"bv\",\n  \"bw\",\n  \"by\",\n  \"bz\",\n  \"bzh\",\n  \"ca\",\n  \"cab\",\n  \"cafe\",\n  \"cal\",\n  \"call\",\n  \"calvinklein\",\n  \"cam\",\n  \"camera\",\n  \"camp\",\n  \"canon\",\n  \"capetown\",\n  \"capital\",\n  \"capitalone\",\n  \"car\",\n  \"caravan\",\n  \"cards\",\n  \"care\",\n  \"career\",\n  \"careers\",\n  \"cars\",\n  \"casa\",\n  \"case\",\n  \"cash\",\n  \"casino\",\n  \"cat\",\n  \"catering\",\n  \"catholic\",\n  \"cba\",\n  \"cbn\",\n  \"cbre\",\n  \"cbs\",\n  \"cc\",\n  \"cd\",\n  \"center\",\n  \"ceo\",\n  \"cern\",\n  \"cf\",\n  \"cfa\",\n  \"cfd\",\n  \"cg\",\n  \"ch\",\n  \"chanel\",\n  \"channel\",\n  \"charity\",\n  \"chase\",\n  \"chat\",\n  \"cheap\",\n  \"chintai\",\n  \"christmas\",\n  \"chrome\",\n  \"church\",\n  \"ci\",\n  \"cipriani\",\n  \"circle\",\n  \"cisco\",\n  \"citadel\",\n  \"citi\",\n  \"citic\",\n  \"city\",\n  \"cityeats\",\n  \"ck\",\n  \"cl\",\n  \"claims\",\n  \"cleaning\",\n  \"click\",\n  \"clinic\",\n  \"clinique\",\n  \"clothing\",\n  \"cloud\",\n  \"club\",\n  \"clubmed\",\n  \"cm\",\n  \"cn\",\n  \"co\",\n  \"coach\",\n  \"codes\",\n  \"coffee\",\n  \"college\",\n  \"cologne\",\n  \"com\",\n  \"comcast\",\n  \"commbank\",\n  \"community\",\n  \"company\",\n  \"compare\",\n  \"computer\",\n  \"comsec\",\n  \"condos\",\n  \"construction\",\n  \"consulting\",\n  \"contact\",\n  \"contractors\",\n  \"cooking\",\n  \"cookingchannel\",\n  \"cool\",\n  \"coop\",\n  \"corsica\",\n  \"country\",\n  \"coupon\",\n  \"coupons\",\n  \"courses\",\n  \"cpa\",\n  \"cr\",\n  \"credit\",\n  \"creditcard\",\n  \"creditunion\",\n  \"cricket\",\n  \"crown\",\n  \"crs\",\n  \"cruise\",\n  \"cruises\",\n  \"cu\",\n  \"cuisinella\",\n  \"cv\",\n  \"cw\",\n  \"cx\",\n  \"cy\",\n  \"cymru\",\n  \"cyou\",\n  \"cz\",\n  \"dabur\",\n  \"dad\",\n  \"dance\",\n  \"data\",\n  \"date\",\n  \"dating\",\n  \"datsun\",\n  \"day\",\n  \"dclk\",\n  \"dds\",\n  \"de\",\n  \"deal\",\n  \"dealer\",\n  \"deals\",\n  \"degree\",\n  \"delivery\",\n  \"dell\",\n  \"deloitte\",\n  \"delta\",\n  \"democrat\",\n  \"dental\",\n  \"dentist\",\n  \"desi\",\n  \"design\",\n  \"dev\",\n  \"dhl\",\n  \"diamonds\",\n  \"diet\",\n  \"digital\",\n  \"direct\",\n  \"directory\",\n  \"discount\",\n  \"discover\",\n  \"dish\",\n  \"diy\",\n  \"dj\",\n  \"dk\",\n  \"dm\",\n  \"dnp\",\n  \"do\",\n  \"docs\",\n  \"doctor\",\n  \"dog\",\n  \"domains\",\n  \"dot\",\n  \"download\",\n  \"drive\",\n  \"dtv\",\n  \"dubai\",\n  \"dunlop\",\n  \"dupont\",\n  \"durban\",\n  \"dvag\",\n  \"dvr\",\n  \"dz\",\n  \"earth\",\n  \"eat\",\n  \"ec\",\n  \"eco\",\n  \"edeka\",\n  \"edu\",\n  \"education\",\n  \"ee\",\n  \"eg\",\n  \"email\",\n  \"emerck\",\n  \"energy\",\n  \"engineer\",\n  \"engineering\",\n  \"enterprises\",\n  \"epson\",\n  \"equipment\",\n  \"er\",\n  \"ericsson\",\n  \"erni\",\n  \"es\",\n  \"esq\",\n  \"estate\",\n  \"et\",\n  \"etisalat\",\n  \"eu\",\n  \"eurovision\",\n  \"eus\",\n  \"events\",\n  \"exchange\",\n  \"expert\",\n  \"exposed\",\n  \"express\",\n  \"extraspace\",\n  \"fage\",\n  \"fail\",\n  \"fairwinds\",\n  \"faith\",\n  \"family\",\n  \"fan\",\n  \"fans\",\n  \"farm\",\n  \"farmers\",\n  \"fashion\",\n  \"fast\",\n  \"fedex\",\n  \"feedback\",\n  \"ferrari\",\n  \"ferrero\",\n  \"fi\",\n  \"fiat\",\n  \"fidelity\",\n  \"fido\",\n  \"film\",\n  \"final\",\n  \"finance\",\n  \"financial\",\n  \"fire\",\n  \"firestone\",\n  \"firmdale\",\n  \"fish\",\n  \"fishing\",\n  \"fit\",\n  \"fitness\",\n  \"fj\",\n  \"fk\",\n  \"flickr\",\n  \"flights\",\n  \"flir\",\n  \"florist\",\n  \"flowers\",\n  \"fly\",\n  \"fm\",\n  \"fo\",\n  \"foo\",\n  \"food\",\n  \"foodnetwork\",\n  \"football\",\n  \"ford\",\n  \"forex\",\n  \"forsale\",\n  \"forum\",\n  \"foundation\",\n  \"fox\",\n  \"fr\",\n  \"free\",\n  \"fresenius\",\n  \"frl\",\n  \"frogans\",\n  \"frontdoor\",\n  \"frontier\",\n  \"ftr\",\n  \"fujitsu\",\n  \"fun\",\n  \"fund\",\n  \"furniture\",\n  \"futbol\",\n  \"fyi\",\n  \"ga\",\n  \"gal\",\n  \"gallery\",\n  \"gallo\",\n  \"gallup\",\n  \"game\",\n  \"games\",\n  \"gap\",\n  \"garden\",\n  \"gay\",\n  \"gb\",\n  \"gbiz\",\n  \"gd\",\n  \"gdn\",\n  \"ge\",\n  \"gea\",\n  \"gent\",\n  \"genting\",\n  \"george\",\n  \"gf\",\n  \"gg\",\n  \"ggee\",\n  \"gh\",\n  \"gi\",\n  \"gift\",\n  \"gifts\",\n  \"gives\",\n  \"giving\",\n  \"gl\",\n  \"glass\",\n  \"gle\",\n  \"global\",\n  \"globo\",\n  \"gm\",\n  \"gmail\",\n  \"gmbh\",\n  \"gmo\",\n  \"gmx\",\n  \"gn\",\n  \"godaddy\",\n  \"gold\",\n  \"goldpoint\",\n  \"golf\",\n  \"goo\",\n  \"goodyear\",\n  \"goog\",\n  \"google\",\n  \"gop\",\n  \"got\",\n  \"gov\",\n  \"gp\",\n  \"gq\",\n  \"gr\",\n  \"grainger\",\n  \"graphics\",\n  \"gratis\",\n  \"green\",\n  \"gripe\",\n  \"grocery\",\n  \"group\",\n  \"gs\",\n  \"gt\",\n  \"gu\",\n  \"guardian\",\n  \"gucci\",\n  \"guge\",\n  \"guide\",\n  \"guitars\",\n  \"guru\",\n  \"gw\",\n  \"gy\",\n  \"hair\",\n  \"hamburg\",\n  \"hangout\",\n  \"haus\",\n  \"hbo\",\n  \"hdfc\",\n  \"hdfcbank\",\n  \"health\",\n  \"healthcare\",\n  \"help\",\n  \"helsinki\",\n  \"here\",\n  \"hermes\",\n  \"hgtv\",\n  \"hiphop\",\n  \"hisamitsu\",\n  \"hitachi\",\n  \"hiv\",\n  \"hk\",\n  \"hkt\",\n  \"hm\",\n  \"hn\",\n  \"hockey\",\n  \"holdings\",\n  \"holiday\",\n  \"homedepot\",\n  \"homegoods\",\n  \"homes\",\n  \"homesense\",\n  \"honda\",\n  \"horse\",\n  \"hospital\",\n  \"host\",\n  \"hosting\",\n  \"hot\",\n  \"hoteles\",\n  \"hotels\",\n  \"hotmail\",\n  \"house\",\n  \"how\",\n  \"hr\",\n  \"hsbc\",\n  \"ht\",\n  \"hu\",\n  \"hughes\",\n  \"hyatt\",\n  \"hyundai\",\n  \"ibm\",\n  \"icbc\",\n  \"ice\",\n  \"icu\",\n  \"id\",\n  \"ie\",\n  \"ieee\",\n  \"ifm\",\n  \"ikano\",\n  \"il\",\n  \"im\",\n  \"imamat\",\n  \"imdb\",\n  \"immo\",\n  \"immobilien\",\n  \"in\",\n  \"inc\",\n  \"industries\",\n  \"infiniti\",\n  \"info\",\n  \"ing\",\n  \"ink\",\n  \"institute\",\n  \"insurance\",\n  \"insure\",\n  \"int\",\n  \"international\",\n  \"intuit\",\n  \"investments\",\n  \"io\",\n  \"ipiranga\",\n  \"iq\",\n  \"ir\",\n  \"irish\",\n  \"is\",\n  \"ismaili\",\n  \"ist\",\n  \"istanbul\",\n  \"it\",\n  \"itau\",\n  \"itv\",\n  \"jaguar\",\n  \"java\",\n  \"jcb\",\n  \"je\",\n  \"jeep\",\n  \"jetzt\",\n  \"jewelry\",\n  \"jio\",\n  \"jll\",\n  \"jm\",\n  \"jmp\",\n  \"jnj\",\n  \"jo\",\n  \"jobs\",\n  \"joburg\",\n  \"jot\",\n  \"joy\",\n  \"jp\",\n  \"jpmorgan\",\n  \"jprs\",\n  \"juegos\",\n  \"juniper\",\n  \"kaufen\",\n  \"kddi\",\n  \"ke\",\n  \"kerryhotels\",\n  \"kerrylogistics\",\n  \"kerryproperties\",\n  \"kfh\",\n  \"kg\",\n  \"kh\",\n  \"ki\",\n  \"kia\",\n  \"kids\",\n  \"kim\",\n  \"kinder\",\n  \"kindle\",\n  \"kitchen\",\n  \"kiwi\",\n  \"km\",\n  \"kn\",\n  \"koeln\",\n  \"komatsu\",\n  \"kosher\",\n  \"kp\",\n  \"kpmg\",\n  \"kpn\",\n  \"kr\",\n  \"krd\",\n  \"kred\",\n  \"kuokgroup\",\n  \"kw\",\n  \"ky\",\n  \"kyoto\",\n  \"kz\",\n  \"la\",\n  \"lacaixa\",\n  \"lamborghini\",\n  \"lamer\",\n  \"lancaster\",\n  \"lancia\",\n  \"land\",\n  \"landrover\",\n  \"lanxess\",\n  \"lasalle\",\n  \"lat\",\n  \"latino\",\n  \"latrobe\",\n  \"law\",\n  \"lawyer\",\n  \"lb\",\n  \"lc\",\n  \"lds\",\n  \"lease\",\n  \"leclerc\",\n  \"lefrak\",\n  \"legal\",\n  \"lego\",\n  \"lexus\",\n  \"lgbt\",\n  \"li\",\n  \"lidl\",\n  \"life\",\n  \"lifeinsurance\",\n  \"lifestyle\",\n  \"lighting\",\n  \"like\",\n  \"lilly\",\n  \"limited\",\n  \"limo\",\n  \"lincoln\",\n  \"link\",\n  \"lipsy\",\n  \"live\",\n  \"living\",\n  \"lk\",\n  \"llc\",\n  \"llp\",\n  \"loan\",\n  \"loans\",\n  \"locker\",\n  \"locus\",\n  \"lol\",\n  \"london\",\n  \"lotte\",\n  \"lotto\",\n  \"love\",\n  \"lpl\",\n  \"lplfinancial\",\n  \"lr\",\n  \"ls\",\n  \"lt\",\n  \"ltd\",\n  \"ltda\",\n  \"lu\",\n  \"lundbeck\",\n  \"luxe\",\n  \"luxury\",\n  \"lv\",\n  \"ly\",\n  \"ma\",\n  \"madrid\",\n  \"maif\",\n  \"maison\",\n  \"makeup\",\n  \"man\",\n  \"management\",\n  \"mango\",\n  \"map\",\n  \"market\",\n  \"marketing\",\n  \"markets\",\n  \"marriott\",\n  \"marshalls\",\n  \"maserati\",\n  \"mattel\",\n  \"mba\",\n  \"mc\",\n  \"mckinsey\",\n  \"md\",\n  \"me\",\n  \"med\",\n  \"media\",\n  \"meet\",\n  \"melbourne\",\n  \"meme\",\n  \"memorial\",\n  \"men\",\n  \"menu\",\n  \"merckmsd\",\n  \"mg\",\n  \"mh\",\n  \"miami\",\n  \"microsoft\",\n  \"mil\",\n  \"mini\",\n  \"mint\",\n  \"mit\",\n  \"mitsubishi\",\n  \"mk\",\n  \"ml\",\n  \"mlb\",\n  \"mls\",\n  \"mm\",\n  \"mma\",\n  \"mn\",\n  \"mo\",\n  \"mobi\",\n  \"mobile\",\n  \"moda\",\n  \"moe\",\n  \"moi\",\n  \"mom\",\n  \"monash\",\n  \"money\",\n  \"monster\",\n  \"mormon\",\n  \"mortgage\",\n  \"moscow\",\n  \"moto\",\n  \"motorcycles\",\n  \"mov\",\n  \"movie\",\n  \"mp\",\n  \"mq\",\n  \"mr\",\n  \"ms\",\n  \"msd\",\n  \"mt\",\n  \"mtn\",\n  \"mtr\",\n  \"mu\",\n  \"museum\",\n  \"music\",\n  \"mutual\",\n  \"mv\",\n  \"mw\",\n  \"mx\",\n  \"my\",\n  \"mz\",\n  \"na\",\n  \"nab\",\n  \"nagoya\",\n  \"name\",\n  \"natura\",\n  \"navy\",\n  \"nba\",\n  \"nc\",\n  \"ne\",\n  \"nec\",\n  \"net\",\n  \"netbank\",\n  \"netflix\",\n  \"network\",\n  \"neustar\",\n  \"new\",\n  \"news\",\n  \"next\",\n  \"nextdirect\",\n  \"nexus\",\n  \"nf\",\n  \"nfl\",\n  \"ng\",\n  \"ngo\",\n  \"nhk\",\n  \"ni\",\n  \"nico\",\n  \"nike\",\n  \"nikon\",\n  \"ninja\",\n  \"nissan\",\n  \"nissay\",\n  \"nl\",\n  \"no\",\n  \"nokia\",\n  \"northwesternmutual\",\n  \"norton\",\n  \"now\",\n  \"nowruz\",\n  \"nowtv\",\n  \"np\",\n  \"nr\",\n  \"nra\",\n  \"nrw\",\n  \"ntt\",\n  \"nu\",\n  \"nyc\",\n  \"nz\",\n  \"obi\",\n  \"observer\",\n  \"office\",\n  \"okinawa\",\n  \"olayan\",\n  \"olayangroup\",\n  \"oldnavy\",\n  \"ollo\",\n  \"om\",\n  \"omega\",\n  \"one\",\n  \"ong\",\n  \"onl\",\n  \"online\",\n  \"ooo\",\n  \"open\",\n  \"oracle\",\n  \"orange\",\n  \"org\",\n  \"organic\",\n  \"origins\",\n  \"osaka\",\n  \"otsuka\",\n  \"ott\",\n  \"ovh\",\n  \"pa\",\n  \"page\",\n  \"panasonic\",\n  \"paris\",\n  \"pars\",\n  \"partners\",\n  \"parts\",\n  \"party\",\n  \"passagens\",\n  \"pay\",\n  \"pccw\",\n  \"pe\",\n  \"pet\",\n  \"pf\",\n  \"pfizer\",\n  \"pg\",\n  \"ph\",\n  \"pharmacy\",\n  \"phd\",\n  \"philips\",\n  \"phone\",\n  \"photo\",\n  \"photography\",\n  \"photos\",\n  \"physio\",\n  \"pics\",\n  \"pictet\",\n  \"pictures\",\n  \"pid\",\n  \"pin\",\n  \"ping\",\n  \"pink\",\n  \"pioneer\",\n  \"pizza\",\n  \"pk\",\n  \"pl\",\n  \"place\",\n  \"play\",\n  \"playstation\",\n  \"plumbing\",\n  \"plus\",\n  \"pm\",\n  \"pn\",\n  \"pnc\",\n  \"pohl\",\n  \"poker\",\n  \"politie\",\n  \"porn\",\n  \"post\",\n  \"pr\",\n  \"pramerica\",\n  \"praxi\",\n  \"press\",\n  \"prime\",\n  \"pro\",\n  \"prod\",\n  \"productions\",\n  \"prof\",\n  \"progressive\",\n  \"promo\",\n  \"properties\",\n  \"property\",\n  \"protection\",\n  \"pru\",\n  \"prudential\",\n  \"ps\",\n  \"pt\",\n  \"pub\",\n  \"pw\",\n  \"pwc\",\n  \"py\",\n  \"qa\",\n  \"qpon\",\n  \"quebec\",\n  \"quest\",\n  \"racing\",\n  \"radio\",\n  \"re\",\n  \"read\",\n  \"realestate\",\n  \"realtor\",\n  \"realty\",\n  \"recipes\",\n  \"red\",\n  \"redstone\",\n  \"redumbrella\",\n  \"rehab\",\n  \"reise\",\n  \"reisen\",\n  \"reit\",\n  \"reliance\",\n  \"ren\",\n  \"rent\",\n  \"rentals\",\n  \"repair\",\n  \"report\",\n  \"republican\",\n  \"rest\",\n  \"restaurant\",\n  \"review\",\n  \"reviews\",\n  \"rexroth\",\n  \"rich\",\n  \"richardli\",\n  \"ricoh\",\n  \"ril\",\n  \"rio\",\n  \"rip\",\n  \"ro\",\n  \"rocher\",\n  \"rocks\",\n  \"rodeo\",\n  \"rogers\",\n  \"room\",\n  \"rs\",\n  \"rsvp\",\n  \"ru\",\n  \"rugby\",\n  \"ruhr\",\n  \"run\",\n  \"rw\",\n  \"rwe\",\n  \"ryukyu\",\n  \"sa\",\n  \"saarland\",\n  \"safe\",\n  \"safety\",\n  \"sakura\",\n  \"sale\",\n  \"salon\",\n  \"samsclub\",\n  \"samsung\",\n  \"sandvik\",\n  \"sandvikcoromant\",\n  \"sanofi\",\n  \"sap\",\n  \"sarl\",\n  \"sas\",\n  \"save\",\n  \"saxo\",\n  \"sb\",\n  \"sbi\",\n  \"sbs\",\n  \"sc\",\n  \"sca\",\n  \"scb\",\n  \"schaeffler\",\n  \"schmidt\",\n  \"scholarships\",\n  \"school\",\n  \"schule\",\n  \"schwarz\",\n  \"science\",\n  \"scot\",\n  \"sd\",\n  \"se\",\n  \"search\",\n  \"seat\",\n  \"secure\",\n  \"security\",\n  \"seek\",\n  \"select\",\n  \"sener\",\n  \"services\",\n  \"seven\",\n  \"sew\",\n  \"sex\",\n  \"sexy\",\n  \"sfr\",\n  \"sg\",\n  \"sh\",\n  \"shangrila\",\n  \"sharp\",\n  \"shaw\",\n  \"shell\",\n  \"shia\",\n  \"shiksha\",\n  \"shoes\",\n  \"shop\",\n  \"shopping\",\n  \"shouji\",\n  \"show\",\n  \"showtime\",\n  \"si\",\n  \"silk\",\n  \"sina\",\n  \"singles\",\n  \"site\",\n  \"sj\",\n  \"sk\",\n  \"ski\",\n  \"skin\",\n  \"sky\",\n  \"skype\",\n  \"sl\",\n  \"sling\",\n  \"sm\",\n  \"smart\",\n  \"smile\",\n  \"sn\",\n  \"sncf\",\n  \"so\",\n  \"soccer\",\n  \"social\",\n  \"softbank\",\n  \"software\",\n  \"sohu\",\n  \"solar\",\n  \"solutions\",\n  \"song\",\n  \"sony\",\n  \"soy\",\n  \"spa\",\n  \"space\",\n  \"sport\",\n  \"spot\",\n  \"sr\",\n  \"srl\",\n  \"ss\",\n  \"st\",\n  \"stada\",\n  \"staples\",\n  \"star\",\n  \"statebank\",\n  \"statefarm\",\n  \"stc\",\n  \"stcgroup\",\n  \"stockholm\",\n  \"storage\",\n  \"store\",\n  \"stream\",\n  \"studio\",\n  \"study\",\n  \"style\",\n  \"su\",\n  \"sucks\",\n  \"supplies\",\n  \"supply\",\n  \"support\",\n  \"surf\",\n  \"surgery\",\n  \"suzuki\",\n  \"sv\",\n  \"swatch\",\n  \"swiss\",\n  \"sx\",\n  \"sy\",\n  \"sydney\",\n  \"systems\",\n  \"sz\",\n  \"tab\",\n  \"taipei\",\n  \"talk\",\n  \"taobao\",\n  \"target\",\n  \"tatamotors\",\n  \"tatar\",\n  \"tattoo\",\n  \"tax\",\n  \"taxi\",\n  \"tc\",\n  \"tci\",\n  \"td\",\n  \"tdk\",\n  \"team\",\n  \"tech\",\n  \"technology\",\n  \"tel\",\n  \"temasek\",\n  \"tennis\",\n  \"teva\",\n  \"tf\",\n  \"tg\",\n  \"th\",\n  \"thd\",\n  \"theater\",\n  \"theatre\",\n  \"tiaa\",\n  \"tickets\",\n  \"tienda\",\n  \"tiffany\",\n  \"tips\",\n  \"tires\",\n  \"tirol\",\n  \"tj\",\n  \"tjmaxx\",\n  \"tjx\",\n  \"tk\",\n  \"tkmaxx\",\n  \"tl\",\n  \"tm\",\n  \"tmall\",\n  \"tn\",\n  \"to\",\n  \"today\",\n  \"tokyo\",\n  \"tools\",\n  \"top\",\n  \"toray\",\n  \"toshiba\",\n  \"total\",\n  \"tours\",\n  \"town\",\n  \"toyota\",\n  \"toys\",\n  \"tr\",\n  \"trade\",\n  \"trading\",\n  \"training\",\n  \"travel\",\n  \"travelchannel\",\n  \"travelers\",\n  \"travelersinsurance\",\n  \"trust\",\n  \"trv\",\n  \"tt\",\n  \"tube\",\n  \"tui\",\n  \"tunes\",\n  \"tushu\",\n  \"tv\",\n  \"tvs\",\n  \"tw\",\n  \"tz\",\n  \"ua\",\n  \"ubank\",\n  \"ubs\",\n  \"ug\",\n  \"uk\",\n  \"unicom\",\n  \"university\",\n  \"uno\",\n  \"uol\",\n  \"ups\",\n  \"us\",\n  \"uy\",\n  \"uz\",\n  \"va\",\n  \"vacations\",\n  \"vana\",\n  \"vanguard\",\n  \"vc\",\n  \"ve\",\n  \"vegas\",\n  \"ventures\",\n  \"verisign\",\n  \"verm\\xF6gensberater\",\n  \"verm\\xF6gensberatung\",\n  \"versicherung\",\n  \"vet\",\n  \"vg\",\n  \"vi\",\n  \"viajes\",\n  \"video\",\n  \"vig\",\n  \"viking\",\n  \"villas\",\n  \"vin\",\n  \"vip\",\n  \"virgin\",\n  \"visa\",\n  \"vision\",\n  \"viva\",\n  \"vivo\",\n  \"vlaanderen\",\n  \"vn\",\n  \"vodka\",\n  \"volkswagen\",\n  \"volvo\",\n  \"vote\",\n  \"voting\",\n  \"voto\",\n  \"voyage\",\n  \"vu\",\n  \"vuelos\",\n  \"wales\",\n  \"walmart\",\n  \"walter\",\n  \"wang\",\n  \"wanggou\",\n  \"watch\",\n  \"watches\",\n  \"weather\",\n  \"weatherchannel\",\n  \"webcam\",\n  \"weber\",\n  \"website\",\n  \"wed\",\n  \"wedding\",\n  \"weibo\",\n  \"weir\",\n  \"wf\",\n  \"whoswho\",\n  \"wien\",\n  \"wiki\",\n  \"williamhill\",\n  \"win\",\n  \"windows\",\n  \"wine\",\n  \"winners\",\n  \"wme\",\n  \"wolterskluwer\",\n  \"woodside\",\n  \"work\",\n  \"works\",\n  \"world\",\n  \"wow\",\n  \"ws\",\n  \"wtc\",\n  \"wtf\",\n  \"xbox\",\n  \"xerox\",\n  \"xfinity\",\n  \"xihuan\",\n  \"xin\",\n  \"xxx\",\n  \"xyz\",\n  \"yachts\",\n  \"yahoo\",\n  \"yamaxun\",\n  \"yandex\",\n  \"ye\",\n  \"yodobashi\",\n  \"yoga\",\n  \"yokohama\",\n  \"you\",\n  \"youtube\",\n  \"yt\",\n  \"yun\",\n  \"za\",\n  \"zappos\",\n  \"zara\",\n  \"zero\",\n  \"zip\",\n  \"zm\",\n  \"zone\",\n  \"zuerich\",\n  \"zw\",\n  \"\\u03B5\\u03BB\",\n  \"\\u03B5\\u03C5\",\n  \"\\u0431\\u0433\",\n  \"\\u0431\\u0435\\u043B\",\n  \"\\u0434\\u0435\\u0442\\u0438\",\n  \"\\u0435\\u044E\",\n  \"\\u043A\\u0430\\u0442\\u043E\\u043B\\u0438\\u043A\",\n  \"\\u043A\\u043E\\u043C\",\n  \"\\u043C\\u043A\\u0434\",\n  \"\\u043C\\u043E\\u043D\",\n  \"\\u043C\\u043E\\u0441\\u043A\\u0432\\u0430\",\n  \"\\u043E\\u043D\\u043B\\u0430\\u0439\\u043D\",\n  \"\\u043E\\u0440\\u0433\",\n  \"\\u0440\\u0443\\u0441\",\n  \"\\u0440\\u0444\",\n  \"\\u0441\\u0430\\u0439\\u0442\",\n  \"\\u0441\\u0440\\u0431\",\n  \"\\u0443\\u043A\\u0440\",\n  \"\\u049B\\u0430\\u0437\",\n  \"\\u0570\\u0561\\u0575\",\n  \"\\u05D9\\u05E9\\u05E8\\u05D0\\u05DC\",\n  \"\\u05E7\\u05D5\\u05DD\",\n  \"\\u0627\\u0628\\u0648\\u0638\\u0628\\u064A\",\n  \"\\u0627\\u062A\\u0635\\u0627\\u0644\\u0627\\u062A\",\n  \"\\u0627\\u0631\\u0627\\u0645\\u0643\\u0648\",\n  \"\\u0627\\u0644\\u0627\\u0631\\u062F\\u0646\",\n  \"\\u0627\\u0644\\u0628\\u062D\\u0631\\u064A\\u0646\",\n  \"\\u0627\\u0644\\u062C\\u0632\\u0627\\u0626\\u0631\",\n  \"\\u0627\\u0644\\u0633\\u0639\\u0648\\u062F\\u064A\\u0629\",\n  \"\\u0627\\u0644\\u0639\\u0644\\u064A\\u0627\\u0646\",\n  \"\\u0627\\u0644\\u0645\\u063A\\u0631\\u0628\",\n  \"\\u0627\\u0645\\u0627\\u0631\\u0627\\u062A\",\n  \"\\u0627\\u06CC\\u0631\\u0627\\u0646\",\n  \"\\u0628\\u0627\\u0631\\u062A\",\n  \"\\u0628\\u0627\\u0632\\u0627\\u0631\",\n  \"\\u0628\\u064A\\u062A\\u0643\",\n  \"\\u0628\\u06BE\\u0627\\u0631\\u062A\",\n  \"\\u062A\\u0648\\u0646\\u0633\",\n  \"\\u0633\\u0648\\u062F\\u0627\\u0646\",\n  \"\\u0633\\u0648\\u0631\\u064A\\u0629\",\n  \"\\u0634\\u0628\\u0643\\u0629\",\n  \"\\u0639\\u0631\\u0627\\u0642\",\n  \"\\u0639\\u0631\\u0628\",\n  \"\\u0639\\u0645\\u0627\\u0646\",\n  \"\\u0641\\u0644\\u0633\\u0637\\u064A\\u0646\",\n  \"\\u0642\\u0637\\u0631\",\n  \"\\u0643\\u0627\\u062B\\u0648\\u0644\\u064A\\u0643\",\n  \"\\u0643\\u0648\\u0645\",\n  \"\\u0645\\u0635\\u0631\",\n  \"\\u0645\\u0644\\u064A\\u0633\\u064A\\u0627\",\n  \"\\u0645\\u0648\\u0631\\u064A\\u062A\\u0627\\u0646\\u064A\\u0627\",\n  \"\\u0645\\u0648\\u0642\\u0639\",\n  \"\\u0647\\u0645\\u0631\\u0627\\u0647\",\n  \"\\u067E\\u0627\\u06A9\\u0633\\u062A\\u0627\\u0646\",\n  \"\\u0680\\u0627\\u0631\\u062A\",\n  \"\\u0915\\u0949\\u092E\",\n  \"\\u0928\\u0947\\u091F\",\n  \"\\u092D\\u093E\\u0930\\u0924\",\n  \"\\u092D\\u093E\\u0930\\u0924\\u092E\\u094D\",\n  \"\\u092D\\u093E\\u0930\\u094B\\u0924\",\n  \"\\u0938\\u0902\\u0917\\u0920\\u0928\",\n  \"\\u09AC\\u09BE\\u0982\\u09B2\\u09BE\",\n  \"\\u09AD\\u09BE\\u09B0\\u09A4\",\n  \"\\u09AD\\u09BE\\u09F0\\u09A4\",\n  \"\\u0A2D\\u0A3E\\u0A30\\u0A24\",\n  \"\\u0AAD\\u0ABE\\u0AB0\\u0AA4\",\n  \"\\u0B2D\\u0B3E\\u0B30\\u0B24\",\n  \"\\u0B87\\u0BA8\\u0BCD\\u0BA4\\u0BBF\\u0BAF\\u0BBE\",\n  \"\\u0B87\\u0BB2\\u0B99\\u0BCD\\u0B95\\u0BC8\",\n  \"\\u0B9A\\u0BBF\\u0B99\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0BC2\\u0BB0\\u0BCD\",\n  \"\\u0C2D\\u0C3E\\u0C30\\u0C24\\u0C4D\",\n  \"\\u0CAD\\u0CBE\\u0CB0\\u0CA4\",\n  \"\\u0D2D\\u0D3E\\u0D30\\u0D24\\u0D02\",\n  \"\\u0DBD\\u0D82\\u0D9A\\u0DCF\",\n  \"\\u0E04\\u0E2D\\u0E21\",\n  \"\\u0E44\\u0E17\\u0E22\",\n  \"\\u0EA5\\u0EB2\\u0EA7\",\n  \"\\u10D2\\u10D4\",\n  \"\\u307F\\u3093\\u306A\",\n  \"\\u30A2\\u30DE\\u30BE\\u30F3\",\n  \"\\u30AF\\u30E9\\u30A6\\u30C9\",\n  \"\\u30B0\\u30FC\\u30B0\\u30EB\",\n  \"\\u30B3\\u30E0\",\n  \"\\u30B9\\u30C8\\u30A2\",\n  \"\\u30BB\\u30FC\\u30EB\",\n  \"\\u30D5\\u30A1\\u30C3\\u30B7\\u30E7\\u30F3\",\n  \"\\u30DD\\u30A4\\u30F3\\u30C8\",\n  \"\\u4E16\\u754C\",\n  \"\\u4E2D\\u4FE1\",\n  \"\\u4E2D\\u56FD\",\n  \"\\u4E2D\\u570B\",\n  \"\\u4E2D\\u6587\\u7F51\",\n  \"\\u4E9A\\u9A6C\\u900A\",\n  \"\\u4F01\\u4E1A\",\n  \"\\u4F5B\\u5C71\",\n  \"\\u4FE1\\u606F\",\n  \"\\u5065\\u5EB7\",\n  \"\\u516B\\u5366\",\n  \"\\u516C\\u53F8\",\n  \"\\u516C\\u76CA\",\n  \"\\u53F0\\u6E7E\",\n  \"\\u53F0\\u7063\",\n  \"\\u5546\\u57CE\",\n  \"\\u5546\\u5E97\",\n  \"\\u5546\\u6807\",\n  \"\\u5609\\u91CC\",\n  \"\\u5609\\u91CC\\u5927\\u9152\\u5E97\",\n  \"\\u5728\\u7EBF\",\n  \"\\u5927\\u62FF\",\n  \"\\u5929\\u4E3B\\u6559\",\n  \"\\u5A31\\u4E50\",\n  \"\\u5BB6\\u96FB\",\n  \"\\u5E7F\\u4E1C\",\n  \"\\u5FAE\\u535A\",\n  \"\\u6148\\u5584\",\n  \"\\u6211\\u7231\\u4F60\",\n  \"\\u624B\\u673A\",\n  \"\\u62DB\\u8058\",\n  \"\\u653F\\u52A1\",\n  \"\\u653F\\u5E9C\",\n  \"\\u65B0\\u52A0\\u5761\",\n  \"\\u65B0\\u95FB\",\n  \"\\u65F6\\u5C1A\",\n  \"\\u66F8\\u7C4D\",\n  \"\\u673A\\u6784\",\n  \"\\u6DE1\\u9A6C\\u9521\",\n  \"\\u6E38\\u620F\",\n  \"\\u6FB3\\u9580\",\n  \"\\u70B9\\u770B\",\n  \"\\u79FB\\u52A8\",\n  \"\\u7EC4\\u7EC7\\u673A\\u6784\",\n  \"\\u7F51\\u5740\",\n  \"\\u7F51\\u5E97\",\n  \"\\u7F51\\u7AD9\",\n  \"\\u7F51\\u7EDC\",\n  \"\\u8054\\u901A\",\n  \"\\u8C37\\u6B4C\",\n  \"\\u8D2D\\u7269\",\n  \"\\u901A\\u8CA9\",\n  \"\\u96C6\\u56E2\",\n  \"\\u96FB\\u8A0A\\u76C8\\u79D1\",\n  \"\\u98DE\\u5229\\u6D66\",\n  \"\\u98DF\\u54C1\",\n  \"\\u9910\\u5385\",\n  \"\\u9999\\u683C\\u91CC\\u62C9\",\n  \"\\u9999\\u6E2F\",\n  \"\\uB2F7\\uB137\",\n  \"\\uB2F7\\uCEF4\",\n  \"\\uC0BC\\uC131\",\n  \"\\uD55C\\uAD6D\"\n];\n\n// src/rich-text/detection.ts\nfunction detectFacets(text) {\n  let match;\n  const facets = [];\n  {\n    const re = /(^|\\s|\\()(@)([a-zA-Z0-9.-]+)(\\b)/g;\n    while (match = re.exec(text.utf16)) {\n      if (!isValidDomain(match[3]) && !match[3].endsWith(\".test\")) {\n        continue;\n      }\n      const start = text.utf16.indexOf(match[3], match.index) - 1;\n      facets.push({\n        $type: \"app.bsky.richtext.facet\",\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(start),\n          byteEnd: text.utf16IndexToUtf8Index(start + match[3].length + 1)\n        },\n        features: [\n          {\n            $type: \"app.bsky.richtext.facet#mention\",\n            did: match[3]\n          }\n        ]\n      });\n    }\n  }\n  {\n    const re = /(^|\\s|\\()((https?:\\/\\/[\\S]+)|((?<domain>[a-z][a-z0-9]*(\\.[a-z0-9]+)+)[\\S]*))/gim;\n    while (match = re.exec(text.utf16)) {\n      let uri2 = match[2];\n      if (!uri2.startsWith(\"http\")) {\n        const domain = match.groups?.domain;\n        if (!domain || !isValidDomain(domain)) {\n          continue;\n        }\n        uri2 = `https://${uri2}`;\n      }\n      const start = text.utf16.indexOf(match[2], match.index);\n      const index = { start, end: start + match[2].length };\n      if (/[.,;!?]$/.test(uri2)) {\n        uri2 = uri2.slice(0, -1);\n        index.end--;\n      }\n      if (/[)]$/.test(uri2) && !uri2.includes(\"(\")) {\n        uri2 = uri2.slice(0, -1);\n        index.end--;\n      }\n      facets.push({\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(index.start),\n          byteEnd: text.utf16IndexToUtf8Index(index.end)\n        },\n        features: [\n          {\n            $type: \"app.bsky.richtext.facet#link\",\n            uri: uri2\n          }\n        ]\n      });\n    }\n  }\n  return facets.length > 0 ? facets : void 0;\n}\nfunction isValidDomain(str) {\n  return !!tlds_default.find((tld) => {\n    const i = str.lastIndexOf(tld);\n    if (i === -1) {\n      return false;\n    }\n    return str.charAt(i - 1) === \".\" && i === str.length - tld.length;\n  });\n}\n\n// src/rich-text/rich-text.ts\nvar RichTextSegment = class {\n  constructor(text, facet) {\n    this.text = text;\n    this.facet = facet;\n  }\n  get link() {\n    const link = this.facet?.features.find(facet_exports.isLink);\n    if (facet_exports.isLink(link)) {\n      return link;\n    }\n    return void 0;\n  }\n  isLink() {\n    return !!this.link;\n  }\n  get mention() {\n    const mention = this.facet?.features.find(facet_exports.isMention);\n    if (facet_exports.isMention(mention)) {\n      return mention;\n    }\n    return void 0;\n  }\n  isMention() {\n    return !!this.mention;\n  }\n};\nvar RichText = class {\n  constructor(props, opts) {\n    this.unicodeText = new UnicodeString(props.text);\n    this.facets = props.facets;\n    if (!this.facets?.length && props.entities?.length) {\n      this.facets = entitiesToFacets(this.unicodeText, props.entities);\n    }\n    if (this.facets) {\n      this.facets.sort(facetSort);\n    }\n    if (opts?.cleanNewlines) {\n      sanitizeRichText(this, { cleanNewlines: true }).copyInto(this);\n    }\n  }\n  get text() {\n    return this.unicodeText.toString();\n  }\n  get length() {\n    return this.unicodeText.length;\n  }\n  get graphemeLength() {\n    return this.unicodeText.graphemeLength;\n  }\n  clone() {\n    return new RichText({\n      text: this.unicodeText.utf16,\n      facets: cloneDeep(this.facets)\n    });\n  }\n  copyInto(target) {\n    target.unicodeText = this.unicodeText;\n    target.facets = cloneDeep(this.facets);\n  }\n  *segments() {\n    const facets = this.facets || [];\n    if (!facets.length) {\n      yield new RichTextSegment(this.unicodeText.utf16);\n      return;\n    }\n    let textCursor = 0;\n    let facetCursor = 0;\n    do {\n      const currFacet = facets[facetCursor];\n      if (textCursor < currFacet.index.byteStart) {\n        yield new RichTextSegment(\n          this.unicodeText.slice(textCursor, currFacet.index.byteStart)\n        );\n      } else if (textCursor > currFacet.index.byteStart) {\n        facetCursor++;\n        continue;\n      }\n      if (currFacet.index.byteStart < currFacet.index.byteEnd) {\n        const subtext = this.unicodeText.slice(\n          currFacet.index.byteStart,\n          currFacet.index.byteEnd\n        );\n        if (!subtext.trim()) {\n          yield new RichTextSegment(subtext);\n        } else {\n          yield new RichTextSegment(subtext, currFacet);\n        }\n      }\n      textCursor = currFacet.index.byteEnd;\n      facetCursor++;\n    } while (facetCursor < facets.length);\n    if (textCursor < this.unicodeText.length) {\n      yield new RichTextSegment(\n        this.unicodeText.slice(textCursor, this.unicodeText.length)\n      );\n    }\n  }\n  insert(insertIndex, insertText) {\n    this.unicodeText = new UnicodeString(\n      this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex)\n    );\n    if (!this.facets?.length) {\n      return this;\n    }\n    const numCharsAdded = insertText.length;\n    for (const ent of this.facets) {\n      if (insertIndex <= ent.index.byteStart) {\n        ent.index.byteStart += numCharsAdded;\n        ent.index.byteEnd += numCharsAdded;\n      } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {\n        ent.index.byteEnd += numCharsAdded;\n      }\n    }\n    return this;\n  }\n  delete(removeStartIndex, removeEndIndex) {\n    this.unicodeText = new UnicodeString(\n      this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex)\n    );\n    if (!this.facets?.length) {\n      return this;\n    }\n    const numCharsRemoved = removeEndIndex - removeStartIndex;\n    for (const ent of this.facets) {\n      if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {\n        ent.index.byteStart = 0;\n        ent.index.byteEnd = 0;\n      } else if (removeStartIndex > ent.index.byteEnd) {\n      } else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {\n        ent.index.byteEnd = removeStartIndex;\n      } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {\n        ent.index.byteEnd -= numCharsRemoved;\n      } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {\n        ent.index.byteStart = removeStartIndex;\n        ent.index.byteEnd -= numCharsRemoved;\n      } else if (removeEndIndex < ent.index.byteStart) {\n        ent.index.byteStart -= numCharsRemoved;\n        ent.index.byteEnd -= numCharsRemoved;\n      }\n    }\n    this.facets = this.facets.filter(\n      (ent) => ent.index.byteStart < ent.index.byteEnd\n    );\n    return this;\n  }\n  async detectFacets(agent) {\n    this.facets = detectFacets(this.unicodeText);\n    if (this.facets) {\n      for (const facet of this.facets) {\n        for (const feature of facet.features) {\n          if (facet_exports.isMention(feature)) {\n            const did2 = await agent.resolveHandle({ handle: feature.did }).catch((_) => void 0).then((res) => res?.data.did);\n            feature.did = did2 || \"\";\n          }\n        }\n      }\n      this.facets.sort(facetSort);\n    }\n  }\n  detectFacetsWithoutResolution() {\n    this.facets = detectFacets(this.unicodeText);\n    if (this.facets) {\n      this.facets.sort(facetSort);\n    }\n  }\n};\nvar facetSort = (a, b) => a.index.byteStart - b.index.byteStart;\nfunction entitiesToFacets(text, entities) {\n  const facets = [];\n  for (const ent of entities) {\n    if (ent.type === \"link\") {\n      facets.push({\n        $type: \"app.bsky.richtext.facet\",\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(ent.index.start),\n          byteEnd: text.utf16IndexToUtf8Index(ent.index.end)\n        },\n        features: [{ $type: \"app.bsky.richtext.facet#link\", uri: ent.value }]\n      });\n    } else if (ent.type === \"mention\") {\n      facets.push({\n        $type: \"app.bsky.richtext.facet\",\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(ent.index.start),\n          byteEnd: text.utf16IndexToUtf8Index(ent.index.end)\n        },\n        features: [\n          { $type: \"app.bsky.richtext.facet#mention\", did: ent.value }\n        ]\n      });\n    }\n  }\n  return facets;\n}\nfunction cloneDeep(v) {\n  if (typeof v === \"undefined\") {\n    return v;\n  }\n  return JSON.parse(JSON.stringify(v));\n}\n\n// src/bsky-agent.ts\nvar BskyAgent = class extends AtpAgent {\n  constructor() {\n    super(...arguments);\n    this.getTimeline = (params2, opts) => this.api.app.bsky.feed.getTimeline(params2, opts);\n    this.getAuthorFeed = (params2, opts) => this.api.app.bsky.feed.getAuthorFeed(params2, opts);\n    this.getPostThread = (params2, opts) => this.api.app.bsky.feed.getPostThread(params2, opts);\n    this.getPost = (params2) => this.api.app.bsky.feed.post.get(params2);\n    this.getPosts = (params2, opts) => this.api.app.bsky.feed.getPosts(params2, opts);\n    this.getLikes = (params2, opts) => this.api.app.bsky.feed.getLikes(params2, opts);\n    this.getRepostedBy = (params2, opts) => this.api.app.bsky.feed.getRepostedBy(params2, opts);\n    this.getFollows = (params2, opts) => this.api.app.bsky.graph.getFollows(params2, opts);\n    this.getFollowers = (params2, opts) => this.api.app.bsky.graph.getFollowers(params2, opts);\n    this.getProfile = (params2, opts) => this.api.app.bsky.actor.getProfile(params2, opts);\n    this.getProfiles = (params2, opts) => this.api.app.bsky.actor.getProfiles(params2, opts);\n    this.getSuggestions = (params2, opts) => this.api.app.bsky.actor.getSuggestions(params2, opts);\n    this.searchActors = (params2, opts) => this.api.app.bsky.actor.searchActors(params2, opts);\n    this.searchActorsTypeahead = (params2, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params2, opts);\n    this.listNotifications = (params2, opts) => this.api.app.bsky.notification.listNotifications(params2, opts);\n    this.countUnreadNotifications = (params2, opts) => this.api.app.bsky.notification.getUnreadCount(params2, opts);\n  }\n  get app() {\n    return this.api.app;\n  }\n  async post(record) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    record.createdAt = record.createdAt || new Date().toISOString();\n    return this.api.app.bsky.feed.post.create(\n      { repo: this.session.did },\n      record\n    );\n  }\n  async deletePost(postUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const postUrip = new AtUri(postUri);\n    return await this.api.app.bsky.feed.post.delete({\n      repo: postUrip.hostname,\n      rkey: postUrip.rkey\n    });\n  }\n  async like(uri2, cid2) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    return await this.api.app.bsky.feed.like.create(\n      { repo: this.session.did },\n      {\n        subject: { uri: uri2, cid: cid2 },\n        createdAt: new Date().toISOString()\n      }\n    );\n  }\n  async deleteLike(likeUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const likeUrip = new AtUri(likeUri);\n    return await this.api.app.bsky.feed.like.delete({\n      repo: likeUrip.hostname,\n      rkey: likeUrip.rkey\n    });\n  }\n  async repost(uri2, cid2) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    return await this.api.app.bsky.feed.repost.create(\n      { repo: this.session.did },\n      {\n        subject: { uri: uri2, cid: cid2 },\n        createdAt: new Date().toISOString()\n      }\n    );\n  }\n  async deleteRepost(repostUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const repostUrip = new AtUri(repostUri);\n    return await this.api.app.bsky.feed.repost.delete({\n      repo: repostUrip.hostname,\n      rkey: repostUrip.rkey\n    });\n  }\n  async follow(subjectDid) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    return await this.api.app.bsky.graph.follow.create(\n      { repo: this.session.did },\n      {\n        subject: subjectDid,\n        createdAt: new Date().toISOString()\n      }\n    );\n  }\n  async deleteFollow(followUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const followUrip = new AtUri(followUri);\n    return await this.api.app.bsky.graph.follow.delete({\n      repo: followUrip.hostname,\n      rkey: followUrip.rkey\n    });\n  }\n  async upsertProfile(updateFn) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    let retriesRemaining = 5;\n    while (retriesRemaining >= 0) {\n      const existing = await this.com.atproto.repo.getRecord({\n        repo: this.session.did,\n        collection: \"app.bsky.actor.profile\",\n        rkey: \"self\"\n      }).catch((_) => void 0);\n      const updated = await updateFn(existing?.data.value);\n      if (updated) {\n        updated.$type = \"app.bsky.actor.profile\";\n      }\n      const validation = profile_exports.validateRecord(updated);\n      if (!validation.success) {\n        throw validation.error;\n      }\n      try {\n        await this.com.atproto.repo.putRecord({\n          repo: this.session.did,\n          collection: \"app.bsky.actor.profile\",\n          rkey: \"self\",\n          record: updated,\n          swapRecord: existing?.data.cid || null\n        });\n      } catch (e) {\n        if (retriesRemaining > 0 && e instanceof putRecord_exports.InvalidSwapError) {\n          retriesRemaining--;\n          continue;\n        } else {\n          throw e;\n        }\n      }\n      break;\n    }\n  }\n  async mute(actor) {\n    return this.api.app.bsky.graph.muteActor({ actor });\n  }\n  async unmute(actor) {\n    return this.api.app.bsky.graph.unmuteActor({ actor });\n  }\n  async updateSeenNotifications(seenAt) {\n    seenAt = seenAt || new Date().toISOString();\n    return this.api.app.bsky.notification.updateSeen({\n      seenAt\n    });\n  }\n};\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://hotpicz/./node_modules/@atproto/api/dist/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _atproto_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @atproto/api */ \"./node_modules/@atproto/api/dist/index.js\");\n/* harmony import */ var _atproto_api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_atproto_api__WEBPACK_IMPORTED_MODULE_0__);\nlet cursor = undefined;\nlet settings = undefined;\n\nconst agent = new _atproto_api__WEBPACK_IMPORTED_MODULE_0__.BskyAgent({\n  service: 'https://bsky.social',\n  persistSession: (evt, sess) => {\n    if (evt === \"create\") {\n      localStorage.session = JSON.stringify(sess);\n    }\n  }\n});\ndocument.querySelector('#signin').addEventListener(\"click\", () => {\n  login();\n});\ndocument.querySelector('#loginpage').addEventListener(\"keypress\", event => {\n  if (event.key === \"Enter\") {\n    event.preventDefault();\n    login();\n  }\n});\nif (localStorage.session && localStorage.session !== 'undefined') {\n  agent.resumeSession(JSON.parse(localStorage.session)).then(out => {\n    console.log(out);\n    document.querySelector('#logincontainer').remove();\n    displayImages();\n    document.querySelector('.moar').style.display = 'flex';\n  }).catch(err => {\n    //alert(err)\n  });\n} else {\n  document.querySelector('#logincontainer').style.display = 'flex';\n}\nfunction login() {\n  agent.login({\n    identifier: document.querySelector('#login').value,\n    password: document.querySelector('#pass').value\n  }).then(out => {\n    console.log(out);\n    document.querySelector('#logincontainer').remove();\n    document.querySelector('.moar').style.display = 'flex';\n    displayImages();\n  }).catch(err => {\n    alert(err);\n  });\n}\nfunction displayImages() {\n  if (cursor !== undefined) {\n    settings = {\n      includeNsfw: true,\n      limit: 100,\n      cursor: cursor\n    };\n  } else {\n    settings = {\n      includeNsfw: true,\n      limit: 100\n    };\n  }\n  agent.app.bsky.unspecced.getPopular(settings).then(response => {\n    response.data.feed.forEach(thing => {\n      cursor = response.data.cursor;\n      if (thing.post.embed) {\n        if (thing.post.embed.$type === \"app.bsky.embed.images#view\") {\n          thing.post.embed.images.forEach(image => {\n            let img = document.createElement('img');\n            img.src = image.thumb;\n            img.loading = 'lazy';\n            if (thing.post.labels.some(label => label.val === 'nudity' || label.val === 'sexual')) {\n              img.classList.add(\"explicit\");\n            }\n            let a = document.createElement('a');\n            a.href = `https://staging.bsky.app/profile/${thing.post.author.did}/post/${thing.post.uri.split(\"/\").pop()}`;\n            a.appendChild(img);\n            a.id = 'link';\n            document.querySelector('#images').insertBefore(a, document.querySelector('.moar'));\n          });\n        }\n      }\n    });\n  });\n}\ndocument.querySelector('.moar').addEventListener(\"click\", () => {\n  displayImages();\n});\n\n//# sourceURL=webpack://hotpicz/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;